<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="haocoder">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="haocoder">
<meta property="og:locale">
<meta property="article:author" content="Henry Xue">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>haocoder</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">haocoder</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/01/Rust%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Henry Xue">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haocoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/01/Rust%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">Rust基础概念入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-01 19:29:21" itemprop="dateCreated datePublished" datetime="2020-11-01T19:29:21+08:00">2020-11-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">Rust编程语言</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>22 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">answer</span></span>() -&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(sum(a,b), <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    answer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="变量与绑定"><a href="#变量与绑定" class="headerlink" title="变量与绑定"></a>变量与绑定</h3><h4 id="位置表达式-左值-与值表达式-右值"><a href="#位置表达式-左值-与值表达式-右值" class="headerlink" title="位置表达式(左值)与值表达式(右值)"></a>位置表达式(左值)与值表达式(右值)</h4><p>位置表达式就是表示内存位置的表达式，有以下几类：</p>
<ul>
<li>本地变量</li>
<li>静态变量</li>
<li>解引用（*expr)</li>
<li>数组索引</li>
<li>字段引用(expr.field)</li>
<li>位置表达式组合</li>
</ul>
<p>通过位置表达式可以对某个数据单元的内存进行读写。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">temp</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> _x = &amp;temp();</span><br><span class="line">    <span class="keyword">let</span> _y = temp();</span><br><span class="line">      <span class="comment">// temp()调用是一个值表达式，不能出现在位置上下文中</span></span><br><span class="line">    temp() = *_x;   <span class="comment">// error[E0070]: invalid left-hand side of assignment</span></span><br><span class="line">    temp() = _y     <span class="comment">// error[E0070]: invalid left-hand side of assignment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="不可变绑定与可变绑定"><a href="#不可变绑定与可变绑定" class="headerlink" title="不可变绑定与可变绑定"></a>不可变绑定与可变绑定</h4><p>使用let关键字声明的位置表达式默认是不可变的，为不可变绑定，即值不能修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;  <span class="comment">// immutable</span></span><br><span class="line">    <span class="comment">//a = 2;      // error[E0384]: cannot assign twice to immutable variable `a`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="number">2</span>; <span class="comment">// mutable</span></span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="所有权和引用"><a href="#所有权和引用" class="headerlink" title="所有权和引用"></a>所有权和引用</h4><p>当位置表达式出现在值上下文中（比如赋值运算符右侧），该位置表达式将会把内存地址转移给另外一个位置表达式，这其实就是所有权的转移。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> place1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> other = place1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, other);      <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, place1);        <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    other = <span class="string">&quot;mm&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, other);        <span class="comment">// &quot;mm&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, place1);        <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>place1是一个位置表达式，在<code>let other = place1;</code>中出现在赋值运算符右侧，即一个值上下文内，所以place1会将内存地址转移给other.</p>
<p>在日常开发中，有时候不需要转移所有权，Rust提供了**引用操作符(&amp;)**，可以直接获取表达式的存储单元地址，即内存地址。可以通过该内存地址进行读取。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];          <span class="comment">// 固定长度数组</span></span><br><span class="line">    <span class="keyword">let</span> b = &amp;a;                 <span class="comment">// 取a的地址，不会有所有权转移</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, b);        <span class="comment">// 0x7ffd5114eeb4</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];    <span class="comment">// 动态数组</span></span><br><span class="line">    <span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> c;             <span class="comment">// 获取c的可变引用</span></span><br><span class="line">    d.push(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, d);        <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">      <span class="comment">// 字面量42本身属于值表达式，通过引用操作符，相当于值表达式在位置上下文中进行求值</span></span><br><span class="line">      <span class="comment">// 所以编译器会为&amp;42创建一个临时值</span></span><br><span class="line">    <span class="keyword">let</span> e = &amp;<span class="number">42</span>;                       </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *e);       <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e);        <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, e);        <span class="comment">// 0x55c6ad23d0dc</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, *e);       <span class="comment">// error[E0277]: the trait bound `&#123;integer&#125;: std::fmt::Pointer` is not satisfied</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">42</span>, *e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包"></a>函数与闭包</h3><p><strong>main函数是程序的入口</strong>,对于二进制可执行文件来说，main函数必不可少，但是对于库函数来说，main函数就没那么必要了。</p>
<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数通过关键字<strong>fn</strong>来定义。</p>
<h4 id="作用域与生命周期"><a href="#作用域与生命周期" class="headerlink" title="作用域与生命周期"></a>作用域与生命周期</h4><p>Rust语言的作用域是静态作用域，即词法作用域(Lexical Scope）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="comment">// 连续用let定义同名变量的做法叫变量遮蔽(Variable Shadow)</span></span><br><span class="line">    <span class="keyword">let</span> v = <span class="string">&quot;hello rust&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello rust&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开辟一个新的词法作用域,与外部作用域独立</span></span><br><span class="line">        <span class="keyword">let</span> v = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// thread &#x27;main&#x27; panicked at &#x27;assertion failed: `(left == right)`</span></span><br><span class="line">    <span class="comment">// assert_eq!(v, &quot;hello world&quot;);</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello rust&quot;</span>);   <span class="comment">// success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><strong>在Rust中，函数为一等公民，这意味着，函数自身就可以作为函数的参数或返回值使用</strong>。</p>
<h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数fn有三个参数op, a, b</span></span><br><span class="line"><span class="comment">// op的类型是个函数，其签名为fn(i32,i32)-&gt;i32</span></span><br><span class="line"><span class="comment">// a，b的类型为i32</span></span><br><span class="line"><span class="comment">// fn的返回值类型为i32</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">math</span></span>(op: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>, a: <span class="built_in">i32</span>, b : <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类型为fn(i32, i32) -&gt; i32</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// a + b; // 返回单元类型()</span></span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类型为fn(i32, i32) -&gt; i32</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">product</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a * b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(math(sum, a, b), <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(math(product, a, b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数签名fn()-&gt;bool</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_true</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回类型为fn()-&gt;bool</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">true_marker</span></span>() -&gt; <span class="function"><span class="keyword">fn</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    is_true     <span class="comment">// 将is_true函数指针返回，即可以将函数名作为函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// true_marker()调用返回is_true函数指针,然后再调用is_true函数</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(true_marker()(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CTFE机制"><a href="#CTFE机制" class="headerlink" title="CTFE机制"></a>CTFE机制</h4><p>Rust编译器也可以像C++或D语言那样，拥有<strong>编译时函数执行(Compile-Time Function Execution, CTFE)的能力</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const fn强制编译器在编译期执行函数</span></span><br><span class="line"><span class="comment">// 关键字const一般用于定义全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_len</span></span>() -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化初始值为0，长度为N的数组，N由init_len()在编译期求值而来</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">0</span>; init_len()];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);      <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Rust中的CTFE是由miri来执行的，miri是一个MIR解释器</strong>。</p>
<p>Rust编译器目前可以支持的常量表达式有：字面量、元组、数组、字段结构体、枚举、只包含单行代码的块表达式、范围等。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包也叫匿名函数，闭包有以下特点：</p>
<ul>
<li>可以像函数一样被调用</li>
<li>可以捕获上下文环境中的自由变量</li>
<li>可以自动推断输入和返回的类型</li>
</ul>
<p>C++中的lambda表达式会返回一个闭包，也可以被调用，捕获变量、自动推断类型</p>
<p>闭包调用和函数调用很像，但是闭包和函数有一个重要的区别，<strong>闭包可以捕获外部变量，而函数不可以</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> out = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// error[E0434]: can&#x27;t capture dynamic environment in a fn item</span></span><br><span class="line">    <span class="comment">// 在函数内部使用外部定义的变量out编译器会报错，可以使用闭包来代替</span></span><br><span class="line">    <span class="comment">// fn add(i: i32, j: i32) -&gt; i32 &#123; i + j + out &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(i: <span class="built_in">i32</span>,j: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + j &#125;</span><br><span class="line">    <span class="keyword">let</span> closure_annotated = |i: <span class="built_in">i32</span>, j: <span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="comment">// 定义闭包，可以使用外部定义的变量out</span></span><br><span class="line">        i + j + out</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 定义但没有使用会报错，因为定义闭包时没有指定参数和返回值类型，编译器无法推导类型，但是如果闭包被调用了，可以通过实参类型来推导</span></span><br><span class="line">    <span class="comment">// error[E0282]: type annotations needed</span></span><br><span class="line">    <span class="comment">// The compiler could not infer a type and asked for a type annotation.</span></span><br><span class="line">    <span class="keyword">let</span> closure_inferred = |i, j| i +j + out;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, add(i, j));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_annotated(i, j));</span><br><span class="line">    <span class="comment">// 调用closure_inferred，传递i,j参数会告诉编译器更多信息推到类型</span></span><br><span class="line">    <span class="comment">// 否则只是单独定义closure_inferred，则会编译错误</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_inferred(i, j));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, closure_inferred(i, j))     <span class="comment">//45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包也可以作为函数参数和返回值，但使用起来略有区别</p>
<p><strong>Rust中闭包实际上就是由一个匿名结构体和trait来组合实现的。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包作为参数的情况</span></span><br><span class="line"><span class="comment">// 参数op是泛型类型F， F接受Fn()-&gt;i32 trait的限定</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">closure_math</span></span>&lt;F: <span class="built_in">Fn</span>()-&gt;<span class="built_in">i32</span>&gt;(op: F) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    op()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 调用closure_math时传入闭包||a+b,该闭包实现了Fn()-&gt;i32</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(closure_math(|| a + b), <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 调用closure_math传入闭包||a*b,该闭包实现了Fn()-&gt;i32</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(closure_math(|| a * b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>闭包同样也可以作为返回值</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包作为返回值的情况</span></span><br><span class="line"><span class="comment">// 使用impl Fn(i32)-&gt;i32作为函数返回值,它表示实现了Fn(i32)-&gt;i32的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">two_times_impl</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 使用move返回闭包，因为闭包默认按照引用捕获变量</span></span><br><span class="line">    <span class="comment">// 如果不使用move, 如果闭包的生命周期比函数的长，</span></span><br><span class="line">    <span class="comment">// 则对变量i的引用可能变成悬垂指针</span></span><br><span class="line">    <span class="comment">// 在定义闭包时并不知道具体闭包的类型，因为变量</span></span><br><span class="line">    <span class="comment">// j的类型不知道</span></span><br><span class="line">    <span class="keyword">move</span> |j| j * i</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = two_times_impl();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result(<span class="number">2</span>), <span class="number">4</span>); <span class="comment">// 2最为闭包的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>条件语句和循环语句在Rust中叫做<strong>流程控制表达式</strong>。而表达式一定会有值。所以if表达式的所有分支必须返回同一个类型的值才可以。这也是Rust没有三元操作符?:的原因。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>..<span class="number">20</span> &#123;        <span class="comment">// 1..20是一个Range类型，它是一个迭代器</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;fizzbuzz&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;fizz&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;buzz&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="match表达式与模式匹配"><a href="#match表达式与模式匹配" class="headerlink" title="match表达式与模式匹配"></a>match表达式与模式匹配</h4><p>Rust提供了match表达式，优点类似于其它编程语言中的switch或case语句</p>
<p>match分支使用了模式匹配(Pattern Matching)技术。在Rust语言中，match分支左边就是模式，右边就是执行代码。模式匹配也是一个表达式，所有分支必须返回同一类型，但是左侧的模式可以不同。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Origin&quot;</span>),    <span class="comment">//  单值模式</span></span><br><span class="line">        <span class="comment">// 范围模式,warning: `...` range patterns are deprecated</span></span><br><span class="line">        <span class="comment">// use `..=` for an inclusive range</span></span><br><span class="line">        <span class="comment">// 1...3 =&gt; println!(&quot;All&quot;),</span></span><br><span class="line">        <span class="number">1</span>..= <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;All&quot;</span>),</span><br><span class="line">        |<span class="number">5</span>|<span class="number">7</span>|<span class="number">13</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Bad Luck&quot;</span>),    <span class="comment">// 模式为多个值</span></span><br><span class="line">        n @ <span class="number">42</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Answer is &#123;&#125;&quot;</span>, n),  <span class="comment">// 绑定模式，使用操作符@将模式中的值绑定给一个变量</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Common&quot;</span>),  <span class="comment">// _ 通配符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="if-let和while-let表达式"><a href="#if-let和while-let表达式" class="headerlink" title="if let和while let表达式"></a>if let和while let表达式</h4><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="1-布尔类型"><a href="#1-布尔类型" class="headerlink" title="1. 布尔类型"></a>1. 布尔类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 比较操作会产生bool类型</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123; <span class="built_in">println!</span>(<span class="string">&quot;x is bigger than 1&quot;</span>)&#125;;</span><br><span class="line">    <span class="comment">// 通过as操作符将bool类型转换为数字0和1，</span></span><br><span class="line">    <span class="comment">// Rust不支持将数字转换为bool类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(x <span class="keyword">as</span> <span class="built_in">i32</span>, <span class="number">1</span>);   <span class="comment">// &#x27;assertion failed: `(left == right)`</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(y <span class="keyword">as</span> <span class="built_in">i32</span> ,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-基本数字类型"><a href="#2-基本数字类型" class="headerlink" title="2. 基本数字类型"></a>2. 基本数字类型</h4><ul>
<li>固定大小类型：无符号整数和有符号整数</li>
<li>动态大小类型: usize, isize</li>
<li>浮点数类型： f32, f64</li>
</ul>
<h4 id="3-字符类型"><a href="#3-字符类型" class="headerlink" title="3. 字符类型"></a>3. 字符类型</h4><p>在Rust中，使用单引号来定义字符(Char)类型。 字符类型代表的是一个Unicode标量值，每个字符占4个字节。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;\x2A&#x27;</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;\x25&#x27;</span>,<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-数组类型"><a href="#4-数组类型" class="headerlink" title="4. 数组类型"></a>4. 数组类型</h4><p>数组Array是Rust内建的原始集合类型，数组的特点为：</p>
<ul>
<li>数组大小固定</li>
<li>元素均为同类型</li>
<li>默认不可变</li>
</ul>
<p>数组的类型签名为[T;N], T代表数组中元素类型，N代表数组的长度，是一个编译期常量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 数组类型[i32; 3]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mut_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, mut_arr[<span class="number">0</span>]);</span><br><span class="line">    mut_arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, mut_arr);  <span class="comment">// [3, 2, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);      <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="keyword">let</span> init_arr = [<span class="number">0</span>; <span class="number">10</span>];  <span class="comment">// 初始值为0且长度为10的数组</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, init_arr[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">10</span>, init_arr.len());</span><br><span class="line">   <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, arr[5]);       // index out of bounds: the len is 3 but the index is 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-范围类型"><a href="#5-范围类型" class="headerlink" title="5. 范围类型"></a>5. 范围类型</h4><p>Rust内置了范围(Range)类型，包括<strong>左闭右开</strong>和<strong>全闭</strong>两种区间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..<span class="number">5</span>),  std::ops::Range&#123; start: <span class="number">1</span>, end: <span class="number">5</span>&#125;); <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::ops::Range&#123; start: <span class="number">1</span>, end: <span class="number">3</span>&#125;);  <span class="comment">// 1..3</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..=<span class="number">5</span>), std::ops::RangeInclusive::new(<span class="number">1</span>,<span class="number">5</span>)); <span class="comment">// 全闭</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::ops::RangeInclusive::new(<span class="number">1</span>,<span class="number">5</span>));  <span class="comment">// 1..=5</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>, (<span class="number">3</span>..<span class="number">6</span>).sum());  <span class="comment">// 范围自带方法sum()</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>+<span class="number">6</span>, (<span class="number">3</span>..=<span class="number">6</span>).sum());</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">5</span>) &#123;    <span class="comment">// 每个范围都是一个迭代器</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, i); <span class="comment">// 1,2,3,4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..=<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, i);  <span class="comment">// 1, 2,3,4,5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-切片类型"><a href="#6-切片类型" class="headerlink" title="6. 切片类型"></a>6. 切片类型</h4><p>切片(Slice)类型是对一个数组的引用片段，有利于安全有效的访问数组的一部分，而不需要拷贝。理论上讲，切片引用的是已经存在的变量。在底层，切片代表一个指向数组起始位置的指针和数组长度。用[T]类型表示连续序列，那么切片类型就是&amp;[T]和&amp;mut[T]。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 固定长度数组</span></span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// &amp;arr: 引用数组arr,产生一个切片&amp;arr</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr, &amp;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">// &amp;arr[1..]：对数组进行切割</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr[<span class="number">1</span>..], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">// const fn方法len(),获取切片长度</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr.len(), &amp;<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// const fn方法is_empty()，判断切片是否为空</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr.is_empty(), &amp;<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// &amp;mut 定义可变切片</span></span><br><span class="line">    <span class="keyword">let</span> arr = &amp;<span class="keyword">mut</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);      <span class="comment">// [1,2,3]</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//assert_eq!(arr, [1,7,3]); //error[E0277]: can&#x27;t compare `&amp;mut [&#123;integer&#125;; 3]` with `[&#123;integer&#125;; 3]`</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(arr, &amp;[<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// vec!定义动态数组</span></span><br><span class="line">    <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vec);      <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="comment">// &amp;vec是切片类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;vec, &amp;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// &amp;vec[..]是对切片&amp;vec进行切割获得结果序列[1,2,3]</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;vec[..], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;vec);     <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;vec[<span class="number">1</span>..]); <span class="comment">// [2, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-str字符串类型"><a href="#7-str字符串类型" class="headerlink" title="7. str字符串类型"></a>7. str字符串类型</h4><p>Rust的字符串分为两种类型：</p>
<ul>
<li>str字符串： 固定长度，不可随便改变其长度</li>
<li>String字符串：可增长字符串，可以随意改变其长度</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 定义字符串字面量truth,字符串字面量也属于str类型</span></span><br><span class="line">    <span class="comment">// truth是静态生命周期字符串&amp;&#x27;static str</span></span><br><span class="line">    <span class="keyword">let</span> truth: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;Rust是一门优雅的语言&quot;</span>;</span><br><span class="line">    <span class="comment">// str字符串类型分为两部分</span></span><br><span class="line">    <span class="comment">// 1. 指向字符串序列的指针</span></span><br><span class="line">    <span class="keyword">let</span> ptr = truth.as_ptr();</span><br><span class="line">    <span class="comment">// 2. 字符串长度</span></span><br><span class="line">    <span class="keyword">let</span> len = truth.len();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">28</span>,len);</span><br><span class="line">    <span class="comment">// s是一个str字符串，在unsafe块中执行字节序列到str字符串的转换过程</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// Rust中的字符串本质上是一段有效的UTF8字节序列</span></span><br><span class="line">        <span class="comment">// 将字节序列转换为切片类型&amp;[u8]</span></span><br><span class="line">        <span class="keyword">let</span> slice = std::slice::from_raw_parts(ptr, len);</span><br><span class="line">        <span class="comment">// 将切片slice转换为str字符串</span></span><br><span class="line">        std::<span class="built_in">str</span>::from_utf8(slice)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s, <span class="literal">Ok</span>(truth));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-原生指针"><a href="#8-原生指针" class="headerlink" title="8. 原生指针"></a>8. 原生指针</h4><p>将表示内存地址的类型称为<strong>指针</strong>。Rust提供的多种类型指针：</p>
<ul>
<li>引用(Reference): 本质上是一种非空指针，属于<strong>Safe Rust</strong>，即编译器会对引用进行借用检查，以确保内存安全和类型安全</li>
<li>原生指针(Raw Pointer)： 属于<strong>Unsafe Rust</strong>，直接使用原生指针不安全，因为它可能指向一个Null，或者一个已被释放的内存区域，需要程序员自己保证安全。Rust支持两种原生指针：不可变原生指针<code> *const T</code>和可变原生指针<code>*mut T</code> 。</li>
<li>函数指针(fn Pointer)</li>
<li>智能指针(Smart Pointer)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生指针示例</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">10</span>;         <span class="comment">// x是一个可变绑定</span></span><br><span class="line">    <span class="comment">// 通过as操作符将&amp;mut x可变引用转换为*mut i32可变原生指针ptr_x</span></span><br><span class="line">    <span class="keyword">let</span> ptr_x = &amp;<span class="keyword">mut</span> x <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="comment">// 在堆内存上存储数字20</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 将引用&amp;*y 转换为*const i32不可变原生指针ptr_y</span></span><br><span class="line">    <span class="keyword">let</span> ptr_y = &amp;*y <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *ptr_x += *ptr_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-never类型"><a href="#9-never类型" class="headerlink" title="9. never类型"></a>9. never类型</h4><p>Rust提供了一种特殊数据类型，never类型，即！。该类型用于表示永远不可能有返回值的计算类型，比如线程退出时，就不可能有返回值。因为Rust是一种类型安全的语言，所以也需要将这种情况纳入类型系统中进行统一管理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never类型示例</span></span><br><span class="line"><span class="meta">#![feature(never_type)]</span>  <span class="comment">// never类型属于实验类型，在Nightly版本下使用该特性</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="comment">// x是never类型</span></span><br><span class="line">    <span class="keyword">let</span> x: ! = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>  <span class="comment">// 将123返回，x永远不会被赋值</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num : <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; = <span class="literal">Some</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// match匹配表达式要求所有分支必须返回相同类型</span></span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="comment">// 该分支返回u32类型，编译器没有报错的原因是never类型可以强制转换为其他任何类型</span></span><br><span class="line">        <span class="literal">Some</span>(num) =&gt; num,</span><br><span class="line">        <span class="comment">// panic!宏会返回never类型</span></span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Nothing&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>Rust提供了四种复合数据类型：</p>
<ul>
<li>元组（Tuple)</li>
<li>结构体（Struct）</li>
<li>枚举体（Enum)</li>
<li>联合体（Union)</li>
</ul>
<p>这四种数据类型都是异构数据结构，意味着可以使用它们将多种类型构建为统一的数据类型。</p>
<h4 id="1-元组"><a href="#1-元组" class="headerlink" title="1. 元组"></a>1. 元组</h4><p>元组(Tuple)是一种异构有限序列，形如（T, U, M, N)，异构表示元组内的元素类型可以不同；有限序列指元组有固定的长度</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组示例</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">move_coords</span></span>(x: (<span class="built_in">i32</span>, <span class="built_in">i32</span>)) -&gt; (<span class="built_in">i32</span>, <span class="built_in">i32</span>) &#123;</span><br><span class="line">    (x.<span class="number">0</span> + <span class="number">1</span>, x.<span class="number">1</span> + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// tuple是类型为(&amp;&#x27;static str, i32, char)的元组</span></span><br><span class="line">    <span class="keyword">let</span> tuple: (&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>, <span class="built_in">i32</span>, <span class="built_in">char</span>) = (<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="comment">// 可以通过索引来获取元组内元素的值</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(tuple.<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(tuple.<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> coords = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> result = move_coords(coords);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, (<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// let支持模式匹配，所以可以用来解构元组</span></span><br><span class="line">    <span class="keyword">let</span> (x, y) = move_coords(coords);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-结构体"><a href="#2-结构体" class="headerlink" title="2. 结构体"></a>2. 结构体</h4><p>Rust提供三种结构体：</p>
<ul>
<li>具名结构体（Named-Field Struct)</li>
<li>元组结构体（Tuple-Like Struct)</li>
<li>单元结构体（Unit-Like Struct)</li>
</ul>
<h5 id="具名结构体"><a href="#具名结构体" class="headerlink" title="具名结构体"></a>具名结构体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具名结构体示例</span></span><br><span class="line"><span class="comment">// 该属性可以让结构体自动实现debug trait</span></span><br><span class="line"><span class="comment">// 和PartialEq trait，它们的功能是允许对结构体</span></span><br><span class="line"><span class="comment">// 实体进行打印和比较</span></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="comment">// Rust具名结构体是面向对象思想的一种体现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span> &#123;</span><br><span class="line">    <span class="comment">// 字段格式：name: type</span></span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">    gender: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> People &#123;</span><br><span class="line">    <span class="comment">// 为People结构体实现4个方法</span></span><br><span class="line">    <span class="comment">// 在impl块中定义的函数称为方法，类似于面向对象</span></span><br><span class="line">    <span class="comment">// 不在impl块里定义的函数，就是自由函数</span></span><br><span class="line">    <span class="comment">// new方法类似于面向对象语言中的构造函数</span></span><br><span class="line">    <span class="comment">// new方法参数并没有&amp;self</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>, gender: <span class="built_in">u32</span>)-&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> People&#123;name: name, gender:gender&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数&amp;self代表一个对结构体实例自身的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">name</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;name : &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_name</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">gender</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> gender = <span class="keyword">if</span> (<span class="keyword">self</span>.gender == <span class="number">1</span>) &#123;<span class="string">&quot;boy&quot;</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;girl&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;gender:&#123;:?&#125;&quot;</span>, gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用结构体中定义的相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> alex = People::new(<span class="string">&quot;Alex&quot;</span>, <span class="number">1</span>);  <span class="comment">// 创建Peopoe结构体实体</span></span><br><span class="line">    alex.name();            <span class="comment">// name : &quot;Alex&quot;</span></span><br><span class="line">    alex.gender();          <span class="comment">// gender:&quot;boy&quot;</span></span><br><span class="line">    <span class="comment">// 1. binary operation `==` cannot be applied to type `People`</span></span><br><span class="line">    <span class="comment">// 2. `People` doesn&#x27;t implement `Debug`</span></span><br><span class="line">    <span class="comment">// 报以上两个错误，是因为结构体没有实现debug trait和PartialEq trait</span></span><br><span class="line">    <span class="comment">// 可以使用#[derive(Debug, PartialEq)]属性</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(alex, People &#123; name: <span class="string">&quot;Alex&quot;</span>, gender : <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> alice = People::new(<span class="string">&quot;Alice&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    alice.name();          <span class="comment">// name : &quot;Alice&quot;</span></span><br><span class="line">    alice.gender();        <span class="comment">// gender:&quot;girl&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(alice, People &#123;name: <span class="string">&quot;Alice&quot;</span>, gender: <span class="number">0</span>&#125;);</span><br><span class="line">    alice.set_name(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">    alice.name();           <span class="comment">// name : &quot;Rose&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(alice, People &#123; name: <span class="string">&quot;Rose&quot;</span>, gender: <span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h5><p><strong>特点是，字段没有名称，只有类型</strong>，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组结构体实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span> (<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);   <span class="comment">// 元组结构体后面要加分号</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> color = Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 元组结构体访问字段方式和元组一样，使用圆点记号按位置索引访问</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(color.<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(color.<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>当一个元组结构体只有一个字段的时候，称之为New Type模型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New Type模式示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Integer</span></span>(<span class="built_in">u32</span>);   <span class="comment">// 单字段结构体，相当于把u32类型包装成了新的Integer类型</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Int</span></span> = <span class="built_in">i32</span>;        <span class="comment">// type关键字创建类型别名</span></span><br><span class="line"><span class="comment">// New Type模型属于自定义类型，比type关键字创建类型别名更灵活</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> int = Integer(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(int.<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> int: Int = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(int, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a><strong>单元结构体</strong></h5><p>Rust中可以定义一个没有任何字段的结构体，即单元结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单元结构体示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Empty</span></span>;   <span class="comment">// 没有任何字段的结构体,等价于struct Empty &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = Empty;   <span class="comment">// 单元结构体实例就是其本身</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;x);    <span class="comment">// 0x7ffca81056b8</span></span><br><span class="line">    <span class="comment">// x是位置表达式，而它的上下文是值上下文，所以它的内存地址</span></span><br><span class="line">    <span class="comment">// 会移动给新的位置表达式y</span></span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;y);   <span class="comment">// 0x7ffca8105710</span></span><br><span class="line">    <span class="keyword">let</span> z = Empty;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;z);   <span class="comment">// 0x7ffca8105768</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((..), std::ops::RangeFull);  <span class="comment">// RangeFull表示全范围(..)就是一个单元结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Debug编译模式下，x,y,z是不同的内存地址</p>
</li>
<li><p>在Release编译模式下，x,y,z是相同的内存地址</p>
<p>这证明，在Release编译模式下，单元结构体实例会被优化为同一个对象，而在Debug模式下，不会进行这样的优化。</p>
<p>单元结构体与NewType模式类似，也相当于定义一个新类型，单元结构体一般用于一些特定场景，比如标准库的RangeFull。</p>
</li>
</ul>
<h4 id="3-枚举体"><a href="#3-枚举体" class="headerlink" title="3. 枚举体"></a>3. 枚举体</h4><p>Rust中使用enum关键字定义枚举类型，该类型包含了全部可能的情况，有效防止用户提供无效值。</p>
<p>Rust有三种形式的枚举</p>
<ul>
<li>无参数枚举体</li>
<li>类C枚举体</li>
<li>带参数枚举体</li>
</ul>
<h5 id="无参数枚举"><a href="#无参数枚举" class="headerlink" title="无参数枚举"></a>无参数枚举</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数示例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    <span class="comment">// 三个值，而非类型</span></span><br><span class="line">    Zero,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Number::One;</span><br><span class="line">    <span class="keyword">match</span> a &#123;</span><br><span class="line">        Number::Zero =&gt; <span class="built_in">println!</span>(<span class="string">&quot;0&quot;</span>),</span><br><span class="line">        Number::One =&gt; <span class="built_in">println!</span>(<span class="string">&quot;1&quot;</span>),       <span class="comment">// 1</span></span><br><span class="line">        Number::Two =&gt; <span class="built_in">println!</span>(<span class="string">&quot;2&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="类C枚举体"><a href="#类C枚举体" class="headerlink" title="类C枚举体"></a>类C枚举体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类C枚举体示例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    <span class="comment">// 三个枚举值，并且赋值</span></span><br><span class="line">    Red = <span class="number">0xff0000</span>,</span><br><span class="line">    Green = <span class="number">0x00ff00</span>,</span><br><span class="line">    Blue = <span class="number">0x000ff</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;roses are #&#123;:06x&#125;&quot;</span>, Color::Red <span class="keyword">as</span> <span class="built_in">i32</span>);  <span class="comment">//roses are #ff0000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="带参数枚举体"><a href="#带参数枚举体" class="headerlink" title="带参数枚举体"></a>带参数枚举体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数枚举体示例</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    <span class="comment">// 枚举值携带了类型参数，这样的枚举值本质上属于函数指针</span></span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// IpAddr::V4是类型为fn(u8,u8,u8,u8) -&gt; IpAddr的函数指针</span></span><br><span class="line">    <span class="keyword">let</span> x : <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>) -&gt; IpAddr = IpAddr::V4;</span><br><span class="line">    <span class="keyword">let</span> y : <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">String</span>) -&gt;IpAddr = IpAddr::V6;</span><br><span class="line">    <span class="comment">// 像使用函数调用一样使用带参数枚举</span></span><br><span class="line">    <span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, home);     <span class="comment">// V4(127, 0, 0, 1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p><strong>枚举体在Rust中属于非常重要的类型之一</strong>，一方面为编程提供了很多方便，另一方面，保证了Rust中避免出现空指针。</p>
<h3 id="常用集合类型"><a href="#常用集合类型" class="headerlink" title="常用集合类型"></a>常用集合类型</h3><p>在Rust标准库<code>std::collections</code>集合模块有4中通用集合类型：</p>
<ul>
<li>线性序列：向量(Vec)，双端队列(VecDeque)， 链表(LinkedList)</li>
<li>Key-Value映射表：无序哈希表(HashMap)，有序哈希表(BTreeMap)</li>
<li>集合类型： 无序集合（HashSet)，有序集合(BTreeSet)</li>
<li>优先队列：二叉堆（BinaryHeap)</li>
</ul>
<h4 id="线性序列：-向量"><a href="#线性序列：-向量" class="headerlink" title="线性序列： 向量"></a>线性序列： 向量</h4><p>向量也是数组，但是它可以动态增长</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性序列：向量Vec&lt;T&gt;示例</span></span><br><span class="line"><span class="comment">// Vec&lt;T&gt;会被自动引入</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 第一种初始化方法</span></span><br><span class="line">    <span class="comment">// vec!是一个宏，用来创建向量字面量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1 = <span class="built_in">vec!</span>[];</span><br><span class="line">    v1.push(<span class="number">1</span>);</span><br><span class="line">    v1.push(<span class="number">2</span>);</span><br><span class="line">    v1.push(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 第二种初始化方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v2 = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v2);  <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">      <span class="comment">// 第三种初始化方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v3 = <span class="built_in">Vec</span>::new();</span><br><span class="line">    v3.push(<span class="number">5</span>);</span><br><span class="line">      <span class="comment">//v3.push(&quot;hello&quot;);  // error[E0308]: mismatched types, expected integer, found `&amp;str`</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v3);  <span class="comment">// [5]</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>Rust会对向量和数组进行越界检查</p>
<h4 id="线性序列：双端队列"><a href="#线性序列：双端队列" class="headerlink" title="线性序列：双端队列"></a>线性序列：双端队列</h4><p>是一种同时具有队列和栈性质的数据结构，插入和删除操作被限定在队列的两端进行</p>
<p>Rust中VecDeque是基于可增长的RingBuffer算法实现的双端队列</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性序列：双端队列VecDeque&lt;T&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;  <span class="comment">// 引入VecDeque&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = VecDeque::new();</span><br><span class="line">    buf.push_front(<span class="number">1</span>);</span><br><span class="line">    buf.push_front(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">0</span>), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">1</span>), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    buf.push_back(<span class="number">3</span>);</span><br><span class="line">    buf.push_back(<span class="number">4</span>);</span><br><span class="line">    buf.push_back(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">2</span>), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">3</span>), <span class="literal">Some</span>(&amp;<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线性序列：-链表"><a href="#线性序列：-链表" class="headerlink" title="线性序列： 链表"></a>线性序列： 链表</h4><p>Rust提供了双向链表，允许在任意一端插入或弹出元素。但是通常最好使用Vec或VecDeque，因为它们比链表更加快速，内存访问效率更高，并且可以更好地利用CPU缓存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性序列：双向链表LinkedList&lt;T&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::LinkedList;  <span class="comment">// 引入LinkedList&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list1 = LinkedList::new();</span><br><span class="line">    list1.push_back(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list2 = LinkedList::new();</span><br><span class="line">    list2.push_back(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    list2.push_back(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list2);   <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    list1.append(&amp;<span class="keyword">mut</span> list2);  <span class="comment">// 连接两个链表</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list1);  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list2);  <span class="comment">// []</span></span><br><span class="line">    list1.pop_front();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list1);  <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    list1.push_front(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list1);  <span class="comment">// [&#x27;e&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    list2.push_front(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list2);  <span class="comment">// [&#x27;f&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h4 id="Key-Value映射表：HashMap和BTreeMap"><a href="#Key-Value映射表：HashMap和BTreeMap" class="headerlink" title="Key-Value映射表：HashMap和BTreeMap"></a>Key-Value映射表：HashMap和BTreeMap</h4><p>Rust集合模块提供了两个key-value哈希映射表：</p>
<ul>
<li>HashMap&lt;k, v&gt;</li>
<li>BTreeMap&lt;k, v&gt;</li>
</ul>
<p>key必须是可哈希的类型，value必须是在编译期已知大小的类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Key-Value映射表：HashMap&lt;K,V&gt;和BTreeMap&lt;K,V&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;  <span class="comment">// 引入HashMap</span></span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;  <span class="comment">// 引入BTreeMap</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 创建HashMap和BTreeMap的实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> hmap = HashMap::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bmap = BTreeMap::new();</span><br><span class="line">    hmap.insert(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    hmap.insert(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    bmap.insert(<span class="number">4</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    bmap.insert(<span class="number">1</span>, <span class="string">&quot;e&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, hmap);  <span class="comment">// &#123;3: &quot;c&quot;, 1: &quot;a&quot;&#125;， key顺序不固定，因为HashMap是无序的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, bmap);  <span class="comment">// &#123;1: &quot;3&quot;, 4: &quot;a&quot;&#125;， key是有序的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合：-HashSet和BTreeSet"><a href="#集合：-HashSet和BTreeSet" class="headerlink" title="集合： HashSet和BTreeSet"></a>集合： HashSet和BTreeSet</h4><p><code>HashSet&lt;K&gt;</code>和<code>BTreeSet&lt;K&gt;</code>是<code>HashMap&lt;k, v&gt;</code>，<code>BTreeMap&lt;k, v&gt;</code>把value设置为空元组的特定类型，等价于<code>HashMap&lt;k, ()&gt;</code>和 <code>BTreeMap&lt;k, ()&gt;</code></p>
<ul>
<li>集合中元素是唯一的</li>
<li>集合中元素都是可哈希的类型</li>
<li>HashSet是无序的，BTreeMap是有序的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合： HashSet&lt;k&gt;和BTreeSet&lt;K&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeSet;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> hbooks = HashSet::new();  <span class="comment">// 无序</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bbooks = BTreeSet::new(); <span class="comment">// 有序</span></span><br><span class="line">    hbooks.insert(<span class="string">&quot;A Song of Ice and Fire&quot;</span>);</span><br><span class="line">    hbooks.insert(<span class="string">&quot;The Emerald City&quot;</span>);</span><br><span class="line">    hbooks.insert(<span class="string">&quot;The Odyssey&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> !hbooks.contains(<span class="string">&quot;The Emerald City&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;we have &#123;&#125; books, but no The Emerald City&quot;</span>, hbooks.len());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 顺序随机</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, hbooks);  <span class="comment">// &#123;&quot;The Odyssey&quot;, &quot;The Emerald City&quot;, &quot;A Song of Ice and Fire&quot;&#125;</span></span><br><span class="line">    bbooks.insert(<span class="string">&quot;A Song of Ice and Fire&quot;</span>);</span><br><span class="line">    bbooks.insert(<span class="string">&quot;The Emerald City&quot;</span>);</span><br><span class="line">    bbooks.insert(<span class="string">&quot;The Odyssey&quot;</span>);</span><br><span class="line">    <span class="comment">// 顺序固定</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, bbooks);  <span class="comment">// &#123;&quot;A Song of Ice and Fire&quot;, &quot;The Emerald City&quot;, &quot;The Odyssey&quot;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h4 id="优先队列：-BinaryHeap"><a href="#优先队列：-BinaryHeap" class="headerlink" title="优先队列： BinaryHeap"></a>优先队列： BinaryHeap</h4><p>Rust提供的优先队列是基于二叉最大堆实现的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先队列：BinaryHeap&lt;T&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::BinaryHeap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> heap = BinaryHeap::new();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(heap.peek(), <span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">93</span>, <span class="number">80</span>, <span class="number">48</span>, <span class="number">53</span>, <span class="number">72</span>, <span class="number">30</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">45</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;i <span class="keyword">in</span> arr.iter() &#123;</span><br><span class="line">        heap.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(heap.peek(), <span class="literal">Some</span>(&amp;<span class="number">93</span>));</span><br><span class="line">    <span class="comment">// [93, 80, 48, 53, 72, 30, 18, 36, 15, 35, 45]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>Rust中的值默认被分配到栈内存，可以通过<code>Box&lt;T&gt;</code>将值装箱(在堆内存中分配)。<code>Box&lt;T&gt;</code>是指向类型为T的堆内存分配值的智能指针。当<code>Box&lt;T&gt;</code>超出作用域范围时，将调用其析构函数，销毁内部对象，并自动释放堆中的内存，可以通过解引用操作符来获取<code>Box&lt;T&gt;</code>中的T。</p>
<p>Rust中提供了很多智能指针类型，这里只介绍<code>Box&lt;T&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 智能指针：Box&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">        x : <span class="built_in">f64</span>,</span><br><span class="line">        y : <span class="built_in">f64</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> boxed_point = <span class="built_in">Box</span>::new(Point &#123; x :<span class="number">0.0</span>, y: <span class="number">0.0</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> unboxed_point: Point = *boxed_point;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(unboxed_point, Point &#123;x:<span class="number">0.0</span>, y:<span class="number">0.0</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛型和trait"><a href="#泛型和trait" class="headerlink" title="泛型和trait"></a>泛型和trait</h3><p><strong>泛型</strong>和<strong>trait</strong>是Rust类型系统中最重要的两个概念。</p>
<p><strong>trait</strong>借鉴了Haskell的Typeclass。trait是Rust实现零成本抽象的基石，它有如下机制：</p>
<ul>
<li>trait是rust唯一的接口抽象方式</li>
<li>可以静态生成，也可以动态调用</li>
<li>可以当做标记类型拥有某些特定行为的“标签”来使用。</li>
</ul>
<p><strong>简单来说，trait是对类型行为的抽象</strong>。</p>
<p>Rust中没有继承的概念，它通过trait将类型和行为明确的进行了区分，充分贯彻了组合优于继承和面向接口编程的编程思想。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trait示例</span></span><br><span class="line"><span class="comment">// 定义两个结构体Duck,Pig</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duck</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pig</span></span>;</span><br><span class="line"><span class="comment">// 定义Flay trait</span></span><br><span class="line"><span class="comment">// 在Rust中，trait是唯一的接口抽象方式</span></span><br><span class="line"><span class="comment">// 使用trait可以让不同的类型实现同一种行为，</span></span><br><span class="line"><span class="comment">// 也可以为类型添加新的行为</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fly</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用impl关键字为Duck实现Fly trait</span></span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Duck &#123;</span><br><span class="line">    <span class="comment">// Duck实现fly函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Pig &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. fly_static是泛型函数</span></span><br><span class="line"><span class="comment">// 2. 泛型参数声明类型为T，表示任何类型</span></span><br><span class="line"><span class="comment">// 3. T:Fly语法形式表示使用Flay trait对泛型T进行行为限制，</span></span><br><span class="line"><span class="comment">// 代表T是实现了Fly trait的类型，或者拥有fly这种行为的类型</span></span><br><span class="line"><span class="comment">// 这种限定在Rust中称为trait限定(trait bound),通过trait限定，</span></span><br><span class="line"><span class="comment">// 限制了fly_static泛型参数的类型范围,如果传入的参数不满足</span></span><br><span class="line"><span class="comment">// 该类型限制，则编译器会报错</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;T: Fly&gt;(s: T) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    s.fly()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数是&amp;Fly类型，&amp;Fly类型是一种动态类型，代表拥有fly行为的类型</span></span><br><span class="line"><span class="comment">// fly_static和fly_dyn的区别是，函数实现内fly方法调用机制不同</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(s: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    s.fly()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pig = Pig;</span><br><span class="line">    <span class="comment">// ::&lt;Pig&gt;表示为泛型函数执行具体的类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_static::&lt;Pig&gt;(pig), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">let</span> duck = Duck;</span><br><span class="line">    <span class="comment">// 调用fly_static的这种方式叫静态分发</span></span><br><span class="line">    <span class="comment">// Rust编译器会为fly_static::&lt;Duck&gt;(duck)的调用生成特殊化的代码</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_static::&lt;Duck&gt;(duck), <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// fly_dyn调用属于动态分发，在运行时查找相应类型的方法</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_dyn(&amp;Pig), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_dyn(&amp;Duck), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上例子，Rust的trait完全符合C++之父提出的<strong>零开销原则</strong>：如果你不使用某个抽象，就不用为它付出开销（静态分发）；如果你确实需要使用该抽象，可以保证这是开销最小的使用方式（动态分发）。</p>
<p>Rust中内置了trait，开发者可以通过实现这些trait来扩展自定义类型的行为，比如实现了最常用的Debug trait，就可以拥有在println!宏语句中使用{:?}格式进行打印的行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Debug trait</span></span><br><span class="line"><span class="keyword">use</span> std::fmt::*;   <span class="comment">// 引入Debug trait</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x : <span class="built_in">i32</span>,</span><br><span class="line">    y : <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为Point实现Debug trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Debug</span> <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter) -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Point &#123;&#123;x:&#123;&#125;, y:&#123;&#125;&#125;&#125;&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> origin = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The origin is : &#123;:?&#125;&quot;</span>, origin);  <span class="comment">// The origin is : Point &#123;x:0, y:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Rust中的错误处理是通过返回<code>Result&lt;T, E&gt;</code>类型的方式进行的，<code>Result&lt;T, E&gt;</code>类型是<code>Option&lt;T&gt;</code>类型的升级版本，同样定义在标准库中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Result&lt;T,E&gt; 源码实现, 表示错误的可能性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">enum Result&lt;T, E&gt; &#123;</span></span><br><span class="line"><span class="comment">    Ok(T),</span></span><br><span class="line"><span class="comment">    Err(E),   // 泛型E代表错误Error</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Result&lt;T,E&gt;使用范例</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Ok</span>(-<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x.is_ok(), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Err</span>(<span class="string">&quot;Some error message&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x.is_ok(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 2018版本允许main函数返回<code>Result&lt;T, E&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数返回Result&lt;T,E&gt;</span></span><br><span class="line"><span class="comment">// Result&lt;(), std::io::Error&gt;表示函数返回的错误类型为std::io::Error,</span></span><br><span class="line"><span class="comment">// 正确类型为单元类型()</span></span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), std::io::Error&gt;&#123;</span><br><span class="line">    <span class="comment">// ?操作符是一个错误处理语法糖，会在自动出现错误时返回std::io::Error</span></span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;bar.txt&quot;</span>)?; <span class="comment">// Error: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;</span></span><br><span class="line">    <span class="literal">Ok</span>(())  <span class="comment">// File::open成功时返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="表达式优先级"><a href="#表达式优先级" class="headerlink" title="表达式优先级"></a>表达式优先级</h3><p>在Rust中，一切皆表达式。</p>
<h3 id="注释与打印"><a href="#注释与打印" class="headerlink" title="注释与打印"></a>注释与打印</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>Rust是一门现代语言。Rust文档的哲学是：<strong>代码即文档，文件即代码</strong>。</p>
<p>Rust支持的注释种类：</p>
<ul>
<li>普通注释<ul>
<li>单行注释 //</li>
<li>多行注释 /* … */</li>
</ul>
</li>
<li>文档注释：内部支持Markdown标记，也支持对文档中的示例代码进行测试，可以用rustdoc工具生成HTML文档<ul>
<li>使用///注释可以生成库文档，一般用于函数或结构体的说明，置于说明对象上方</li>
<li>使用//!也可以生成库文档，一般用于说明整个模块的功能，置于模块文件的头部。</li>
</ul>
</li>
</ul>
<h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>使用println!宏语句进行格式化打印，该宏支持的格式化列表：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// println!打印宏</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">// 1. nothing代表display</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">22</span>);    <span class="comment">// 22</span></span><br><span class="line">    <span class="comment">// 2. ?代表Debug</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 22</span></span><br><span class="line">    <span class="comment">// 3. o代表八进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:o&#125;&quot;</span>, <span class="number">22</span>);  <span class="comment">// 26</span></span><br><span class="line">      <span class="comment">// 4. x代表十六进制小写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 16</span></span><br><span class="line">      <span class="comment">// 5. X代表十六进制大写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:X&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 16</span></span><br><span class="line">    <span class="comment">// 6. p代表指针</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;<span class="number">22</span>);  <span class="comment">// 0x560486d5b004</span></span><br><span class="line">      <span class="comment">// 7. b代表二进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:b&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 10110</span></span><br><span class="line">      <span class="comment">// 8. e代表指数小写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:e&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 2.2e1</span></span><br><span class="line">    <span class="comment">// 9. E代表指数大写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:E&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 2.2E1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《Rust编程之道》</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/01/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Henry Xue">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haocoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/01/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">Rust类型系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-01 18:49:25 / Modified: 19:00:39" itemprop="dateCreated datePublished" datetime="2020-11-01T18:49:25+08:00">2020-11-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">Rust编程语言</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>10k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>9 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类型系统与多态性"><a href="#类型系统与多态性" class="headerlink" title="类型系统与多态性"></a>类型系统与多态性</h2><p>现代编程语言包括三种多态形式：</p>
<ul>
<li>参数化多态 （Parametric Polymorphism)： 实际就是指泛型，同一段代码适用于多种类型</li>
<li>Ad-hoc 多态： 也叫特定多态，指同一种行为定义，在不同的上下文中会响应不同的行为实现，Rust使用trait来支持Ad-hoc多态</li>
<li>子类型多态，一般用在面向对象编程语言中，比如Java语言中的多态是子类型多态</li>
</ul>
<p>也可以按照多态发生的时间来划分：</p>
<ul>
<li>静态多态（Static Polymorphism)：发生在编译期，静态多态是一种零成本抽象</li>
<li>动态多态 (Dynamic Polymorphism)： 发生在运行时，牺牲性能获取灵活性。</li>
</ul>
<p><strong>Rust中的类型系统目前只支持参数化多态和Ad-hoc多态，也就是，泛型和trait</strong></p>
<h3 id="Rust类型系统概述"><a href="#Rust类型系统概述" class="headerlink" title="Rust类型系统概述"></a>Rust类型系统概述</h3><p>Rust是一门<strong>强类型且类型安全的静态语言</strong>。Rust中一切皆表达式，表达式皆有值，值皆有类型，所以也可以说Rust中一切皆类型。</p>
<h4 id="1-类型大小"><a href="#1-类型大小" class="headerlink" title="1. 类型大小"></a>1. 类型大小</h4><p>Rust没有GC，内存首先由编译器来分配，Rust代码被编译为LLVM IR,其中携带了内存分配的信息，所以编译器需要事先知道类型的大小，才能分配合理的内存。</p>
<h5 id="可确定大小的类型和动态大小类型"><a href="#可确定大小的类型和动态大小类型" class="headerlink" title="可确定大小的类型和动态大小类型"></a>可确定大小的类型和动态大小类型</h5><ul>
<li>编译器可确定大小的类型 （Sized Type)<ul>
<li>原生整数类型，…..</li>
</ul>
</li>
<li>动态大小类型 (Dynamic Sized Type, DST)<ul>
<li>str类型字符串字面量，编译器事先不知道大小，因此str类型大小无法确切直到</li>
<li>Rust提供了引用类型：&amp;str，即字符串切片，它的大小已知（指向字符串的指针和字符串长度），编译器可以在栈上为&amp;str分配确定大小空间，而str字符串本身是在运行时在堆内存上分配空间存储。</li>
<li>&amp;str是一种胖指针(Fat Pointer)：因为它包含了动态大小类型的地址信息和长度信息，比普通指针占用的空间更大。</li>
<li>str, 数组,</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组直接作为函数参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">reset</span></span>(<span class="keyword">mut</span> arr: [<span class="built_in">u32</span>])   <span class="comment">// 编译错误:doesn&#x27;t have a size known at compile-time，编译器无法确定参数[u32]类型的大小</span></span><br><span class="line">&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;reset arr: &#123;:?&#125;&quot;</span>, arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-指定数组大小解决上述编译错误"><a href="#1-指定数组大小解决上述编译错误" class="headerlink" title="1. 指定数组大小解决上述编译错误"></a>1. 指定数组大小解决上述编译错误</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数参数使用[u32; 5]类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">reset</span></span>(<span class="keyword">mut</span> arr: [<span class="built_in">u32</span>; <span class="number">5</span>])  <span class="comment">// [u32; 5] 确定大小</span></span><br><span class="line">&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;reset arr: &#123;:?&#125;&quot;</span>, arr);  <span class="comment">// reset arr: [5, 4, 3, 2, 1]</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">u32</span>;<span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    reset(arr);  <span class="comment">// 复制一份arr的副本，即数组被传入函数时就会复制一份新的副本</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Origin arr: &#123;:?&#125;&quot;</span>, arr); <span class="comment">// Origin arr: [1, 2, 3, 4, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-使用胖指针解决上述编译错误"><a href="#2-使用胖指针解决上述编译错误" class="headerlink" title="2. 使用胖指针解决上述编译错误"></a>2. 使用胖指针解决上述编译错误</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用&amp;mut[u32]作为参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">reset</span></span>(arr: &amp;<span class="keyword">mut</span> [<span class="built_in">u32</span>])  <span class="comment">// &amp;mut [u32] 可变借用，它包含了长度信息，大小固定，引用作为参数，修改的是原数组</span></span><br><span class="line">&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;reset arr: &#123;:?&#125;&quot;</span>, arr);    <span class="comment">// reset arr: [5, 4, 3, 2, 1]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Array length: &#123;:?&#125;&quot;</span>, arr.len());  <span class="comment">// Array length: 5</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> arr: [<span class="built_in">u32</span>;<span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;reset before : &#123;:?&#125;&quot;</span>, arr); <span class="comment">// Origin arr: [1, 2, 3, 4, 5]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> mut_arr: &amp;<span class="keyword">mut</span> [<span class="built_in">u32</span>] = &amp;<span class="keyword">mut</span> arr;</span><br><span class="line">        reset(mut_arr);  <span class="comment">// 引用作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;reset after : &#123;:?&#125;&quot;</span>, arr); <span class="comment">// reset after : [5, 4, 3, 2, 1]</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较&amp;[u32; 5]类型和&amp;mut [u32]类型空间占用情况</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;&amp;[<span class="built_in">u32</span>; <span class="number">5</span>]&gt;(), <span class="number">8</span>);  <span class="comment">// &amp;[u32; 5]类型为普通指针，占8字节</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;&amp;<span class="keyword">mut</span> [<span class="built_in">u32</span>]&gt;(), <span class="number">16</span>); <span class="comment">// &amp;mut [u32]类型为胖指针，占16字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="零大小类型-（Zero-Size-Type-ZST"><a href="#零大小类型-（Zero-Size-Type-ZST" class="headerlink" title="零大小类型 （Zero Size Type, ZST):"></a>零大小类型 （Zero Size Type, ZST):</h5><ul>
<li>单元类型和单元结构体，大小都是零。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 一组零大小的类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Void</span></span> &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Baz</span></span> &#123;</span><br><span class="line">    foo: Foo,</span><br><span class="line">    qux: (),</span><br><span class="line">    baz: [<span class="built_in">u8</span>; <span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;()&gt;(), <span class="number">0</span>);  <span class="comment">// 单元类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;Foo&gt;(), <span class="number">0</span>); <span class="comment">// 单元结构体</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;Baz&gt;(), <span class="number">0</span>); <span class="comment">// 零大小类型组成的结构体</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;Void&gt;(), <span class="number">0</span>); <span class="comment">// 空枚举</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(std::mem::size_of::&lt;[(); <span class="number">10</span>]&gt;(), <span class="number">0</span>); <span class="comment">// 单元类型组成的数组大小也为0&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="底类型-（Bottom-Type"><a href="#底类型-（Bottom-Type" class="headerlink" title="底类型 （Bottom Type)"></a>底类型 （Bottom Type)</h5><pre><code>起始就是nerver类型：</code></pre>
<ul>
<li><p>没有值</p>
</li>
<li><p>是其它任意类型的子类型</p>
</li>
<li><p>表示”无“</p>
</li>
<li><p>使用叹号 ! 表示</p>
</li>
<li><p>引入这种类型是为了同一管理那些没有值的情况，确保类型安全：</p>
<ul>
<li>发散函数 （Diverging Functio)<ul>
<li>是指会导致线程崩溃的<code>panic!(&quot;this function nerver retures&quot;)</code>或者用于退出函数的<code>std::process::exit</code>，这类函数永远不会有返回值</li>
</ul>
</li>
<li>continue和break关键字<ul>
<li>只表示流程的跳转，不会返回什么</li>
</ul>
</li>
<li>loop循环<ul>
<li>在无限循环的时候没有返回值</li>
</ul>
</li>
<li>空枚举， 比如enum Void{}</li>
</ul>
<p>底类型的一个应用场景是Rust的if语句表达式要求所有分支类型一致，但有时候，分支可能包含了永远无法返回的情况，这是就可以返回底类型，因为它是所有类型的子类型。</p>
</li>
</ul>
<h4 id="2-类型推导"><a href="#2-类型推导" class="headerlink" title="2. 类型推导"></a>2. 类型推导</h4><p>Rust只能在局部范围内进行类型推导。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型推导</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">u32</span>, b:<span class="built_in">i32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    a + (b <span class="keyword">as</span> <span class="built_in">u32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自动推导变量a, b的类型</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(sum(a,b), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">let</span> elem = <span class="number">5u8</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> vec = <span class="built_in">Vec</span>::new();  <span class="comment">// 空向量</span></span><br><span class="line">    vec.push(elem);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(vec, [<span class="number">5</span>]);      <span class="comment">// vec的类型为Vec&lt;u8&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Turbofish操作符"><a href="#Turbofish操作符" class="headerlink" title="Turbofish操作符"></a>Turbofish操作符</h5><p>当Rust无法从上下文中自动推导出类型的时候，编译器就会通过错误信息来提示添加类型标注</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法进行类型推导</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, x.parse().unwrap());</span><br><span class="line">    <span class="comment">/* 错误信息,parse是一个泛型方法，当前无法进行自动类型推导</span></span><br><span class="line"><span class="comment">    error[E0284]: type annotations needed</span></span><br><span class="line"><span class="comment">--&gt; src/main.rs:5:24</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">5 |     println!(&quot;&#123;:?&#125;&quot;, x.parse().unwrap());</span></span><br><span class="line"><span class="comment">  |                        ^^^^^ cannot infer type for type parameter `F` declared on the associated function `parse`</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">  = note: cannot satisfy `&lt;_ as std::str::FromStr&gt;::Err == _`</span></span><br><span class="line"><span class="comment">help: consider specifying the type argument in the method call</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">5 |     println!(&quot;&#123;:?&#125;&quot;, x.parse::&lt;F&gt;().unwrap());</span></span><br><span class="line"><span class="comment">  |                             ^^^^^</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加类型标注信息</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> int_x: <span class="built_in">i32</span> = x.parse().unwrap(); <span class="comment">// 标注类型，想把字符串&quot;1&quot;转换为i32类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(int_x, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种类型标注方法：<strong>turbofish操作符</strong>, 即使用<code>::&lt;type&gt;</code>的形式</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// turbofish操作标注类型信息</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x.parse::&lt;<span class="built_in">i32</span>&gt;().unwrap(), <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust的自动类型推导还有很多缺陷，所以在使用时尽量显式声明类型。</p>
<h4 id="3-泛型"><a href="#3-泛型" class="headerlink" title="3. 泛型"></a>3. 泛型</h4><p>泛型(Generic)是一种参数化多态，使用泛型可以编写更为抽象的代码。泛型就是把一个泛化的类型作为参数，单个类型就可以抽象化为一簇类型。</p>
<h5 id="1-泛型函数、泛型结构体"><a href="#1-泛型函数、泛型结构体" class="headerlink" title="1. 泛型函数、泛型结构体"></a>1. 泛型函数、泛型结构体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;T&gt;(x: T) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(foo(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(foo(<span class="string">&quot;hello&quot;</span>), <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;  <span class="comment">// &lt;T&gt; 是泛型声明，</span></span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型只有被声明之后才可以被使用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型结构体</span></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为泛型结构体实现具体方法时，也需要声明泛型类型</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        Point&#123;x: x, y: y&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> point1 = Point::new(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> point2 = Point::new(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(point1, Point&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(point2, Point&#123;x: <span class="string">&quot;1&quot;</span>, y: <span class="string">&quot;2&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust中的泛型属于静多态，它是一种编译器多态。在编译器，不管是泛型枚举，还是泛型函数和泛型结构体，都会单态化(Monomorphization)。单态化是编译器进行静态分发的一种策略。比如对于一个泛型函数，单态化意味着编译器要将泛型函数生成具体类型对应的函数，也就是C++语言中的实例化。</p>
<p>泛型及单态化是Rust重要的两个功能：优点：单态化静态分发的好处是性能好，没有运行时开销；缺点：容易造成编译后生成的二进制文件膨胀。</p>
<h5 id="2-泛型返回值自动推导"><a href="#2-泛型返回值自动推导" class="headerlink" title="2. 泛型返回值自动推导"></a>2. 泛型返回值自动推导</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型返回值类型的自动推导</span></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>(<span class="built_in">i32</span>);         <span class="comment">// 元组结构体</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bar</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>);   <span class="comment">// 元组结构体</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// trait接口抽象</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Inst</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(i: <span class="built_in">i32</span>) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为结构体Foo实现 Inst trait</span></span><br><span class="line"><span class="keyword">impl</span> Inst <span class="keyword">for</span> Foo &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(i: <span class="built_in">i32</span>) -&gt; Foo &#123;</span><br><span class="line">        Foo(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为结构体Bar实现trait Inst</span></span><br><span class="line"><span class="keyword">impl</span> Inst <span class="keyword">for</span> Bar &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(i: <span class="built_in">i32</span>) -&gt; Bar &#123;</span><br><span class="line">        Bar(i, i + <span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对泛型T进行trait限定，即实现了Inst的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foobar</span></span>&lt;T: Inst&gt;(i: <span class="built_in">i32</span>)-&gt; T &#123;</span><br><span class="line">    T::new(i)    <span class="comment">// 调用T类型的new方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> f: Foo = foobar(<span class="number">10</span>); <span class="comment">// 指定f的类型为Foo,则编译器自动推导出调用Foo::new方法</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(f, Foo(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">let</span> b: Bar = foobar(<span class="number">20</span>); <span class="comment">// 编译器自动推导出调用Bar::new方法</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(b, Bar(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-深入trait"><a href="#4-深入trait" class="headerlink" title="4. 深入trait"></a>4. 深入trait</h4><p>Rust中的所有抽象，比如接口抽象，OOP范式抽象，函数式范式抽象等，均基于trait完成。同时trait也保证了这些抽象几乎都是运行时零开销的。</p>
<p><strong>trait</strong>:</p>
<ul>
<li>从类型系统角度来说，trait是Rust对Ad-hoc多态的支持。</li>
<li>从语义上来说，trait是在行为上对类型的约束，这种约束让trait有以下4中用法：<ul>
<li>接口抽象： 接口是对类型行为的统一约束</li>
<li>泛型约束：泛型的行为被trait限定在更有限的范围内</li>
<li>抽象类型：在运行时作为一种间接的抽象类型去使用，动态地分发给具体的类型</li>
<li>标签trait:  对类型的约束，可以直接作为一种“标签”使用。</li>
</ul>
</li>
</ul>
<h5 id="4-1-接口抽象"><a href="#4-1-接口抽象" class="headerlink" title="4.1 接口抽象"></a>4.1 接口抽象</h5><p>Ad-hoc多态： 同一个trait，在不同的上下文中实现的行为不同。为不同的类型实现trait，属于一种函数重载，也可以说函数重载就是一种Ad-hoc多态。</p>
<h6 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h6><p>待补充</p>
<h6 id="trait一致性"><a href="#trait一致性" class="headerlink" title="trait一致性"></a>trait一致性</h6><ul>
<li>通过实现标准库中的Add trait功能实现操作符的重载。标准库中的u32和u64是不能直接相加的，因为没有实现Add trait。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a : <span class="built_in">u32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> b : <span class="built_in">u64</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> c = a + b;  <span class="comment">// cannot add `u64` to `u32`</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, c);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    error[E0308]: mismatched types</span></span><br><span class="line"><span class="comment">--&gt; src/main.rs:5:17</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">5 |     let c = a + b;</span></span><br><span class="line"><span class="comment">  |                 ^ expected `u32`, found `u64`</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">error[E0277]: cannot add `u64` to `u32`</span></span><br><span class="line"><span class="comment">--&gt; src/main.rs:5:15</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">5 |     let c = a + b;</span></span><br><span class="line"><span class="comment">  |               ^ no implementation for `u32 + u64`</span></span><br><span class="line"><span class="comment">  |</span></span><br><span class="line"><span class="comment">  = help: the trait `std::ops::Add&lt;u64&gt;` is not implemented for `u32</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>尝试通过实现标准库的Add trait来支持u32和u64相加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">use std::ops::Add;</span><br><span class="line">impl Add&lt;u64&gt; for u32 &#123;</span><br><span class="line">    type Output &#x3D; u64;  &#x2F;&#x2F; 关联类型</span><br><span class="line">    fn add(self, other: u64) -&gt; Self::Output &#123;</span><br><span class="line">        (self as u64) + other</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fn main() &#123;</span><br><span class="line">    let a &#x3D; 1u32;</span><br><span class="line">    let b &#x3D; 2u64;</span><br><span class="line">    assert_eq!(a + b, 3);</span><br><span class="line">    &#x2F;*</span><br><span class="line">    error[E0117]: only traits defined in the current crate can be implemented for arbitrary types</span><br><span class="line">--&gt; src&#x2F;main.rs:2:1</span><br><span class="line">  |</span><br><span class="line">2 | impl Add&lt;u64&gt; for u32 &#123;</span><br><span class="line">  | ^^^^^--------^^^^^---</span><br><span class="line">  | |    |            |</span><br><span class="line">  | |    |            &#96;u32&#96; is not defined in the current crate</span><br><span class="line">  | |    &#96;u64&#96; is not defined in the current crate</span><br><span class="line">  | impl doesn&#39;t use only types from inside the current crate</span><br><span class="line">  |</span><br><span class="line">  &#x3D; note: define and implement a trait or new type instead</span><br><span class="line"> </span><br><span class="line">    *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出错，因为Rust遵循一条重要的规则：<strong>孤儿规则(Orphan Rule)，规定如果要实现某个trait，那么该trait和要实现该trait的那个类型至少有一个在当前的crate中定义。</strong>而Add trait,u32和u64都不是在当前trait中定义的，而是定义与标准库中的。如果没有孤儿规则的限制，标准库中的u32的加法行为就会被破坏性的改写。</p>
<ul>
<li>在当前crate中定义Add trait(不违反孤儿规则)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在当前crate中定义Add trait</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt;Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实现Add时将RHS和关联类型指定u64类型</span></span><br><span class="line"><span class="keyword">impl</span> Add&lt;<span class="built_in">u64</span>&gt; <span class="keyword">for</span> <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = <span class="built_in">u64</span>;  <span class="comment">// 关联类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: <span class="built_in">u64</span>) -&gt; Self::Output &#123;</span><br><span class="line">        (<span class="keyword">self</span> <span class="keyword">as</span> <span class="built_in">u64</span>) + other</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1u32</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2u64</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.add(b), <span class="number">3</span>);   <span class="comment">// 调用dd相加，而不是操作符+，否则会被Rust识别为标准库中的Add实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在本地创建新类型，并实现标准库Add trait(不违反)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地创建新类型并实现标准库Add trait</span></span><br><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x : <span class="built_in">i32</span>,</span><br><span class="line">    y : <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实现标准库Add trait让Point也支持加号操作符+</span></span><br><span class="line"><span class="keyword">impl</span> Add <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Point;  <span class="comment">// 关联类型Output必须指定具体类型</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Point) -&gt; Point &#123;   <span class="comment">// 返回类型也可以写Self, Self::Output</span></span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, Point &#123;x: <span class="number">1</span>, y: <span class="number">0</span>&#125; + Point &#123;x: <span class="number">2</span>, y: <span class="number">3</span>&#125;);  <span class="comment">// Point &#123; x: 3, y: 3 &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="trait继承"><a href="#trait继承" class="headerlink" title="trait继承"></a>trait继承</h6><p>Rust不支持传统面向对象的继承，但支持trait继承。子trait可以继承父trait中定义或实现的方法。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trait继承示例</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Page</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 这里要用&amp;Self,而不是self,否则编译会报错，还没搞清楚</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_page</span></span>(&amp;<span class="keyword">self</span>, p: <span class="built_in">i32</span>) -&gt;() &#123; <span class="comment">// 或者不加-&gt;()</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Page Default: 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PerPage</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_perpage</span></span>(&amp;<span class="keyword">self</span>, num: <span class="built_in">i32</span>) -&gt;() &#123; <span class="comment">// 或者不加-&gt;()</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Per Page default: 10&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPaginate</span></span> &#123;</span><br><span class="line">    page: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为MyPaginate实现Page和PerPage，空impl块表示使用trait的默认实现</span></span><br><span class="line"><span class="keyword">impl</span> Page <span class="keyword">for</span> MyPaginate &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> PerPage <span class="keyword">for</span> MyPaginate &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_paginate = MyPaginate&#123;page: <span class="number">1</span>&#125;;</span><br><span class="line">    my_paginate.set_page(<span class="number">2</span>);      <span class="comment">// Page Default: 1</span></span><br><span class="line">    my_paginate.set_perpage(<span class="number">100</span>);  <span class="comment">//Per Page default: 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="通过trait继承扩展功能功能"><a href="#通过trait继承扩展功能功能" class="headerlink" title="通过trait继承扩展功能功能"></a>通过trait继承扩展功能功能</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trait继承示例</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Page</span></span> &#123;</span><br><span class="line">  <span class="comment">// 这里要用&amp;Self,而不是self,否则编译会报错，还没搞清楚</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_page</span></span>(&amp;<span class="keyword">self</span>, p: <span class="built_in">i32</span>) -&gt;() &#123; <span class="comment">// 或者不加-&gt;()</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Page Default: 1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PerPage</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_perpage</span></span>(&amp;<span class="keyword">self</span>, num: <span class="built_in">i32</span>) -&gt;() &#123; <span class="comment">// 或者不加-&gt;()</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Per Page default: 10&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyPaginate</span></span> &#123;</span><br><span class="line">    page: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为MyPaginate实现Page和PerPage，空impl块表示使用trait的默认实现</span></span><br><span class="line"><span class="keyword">impl</span> Page <span class="keyword">for</span> MyPaginate &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> PerPage <span class="keyword">for</span> MyPaginate &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用trait继承扩展功能</span></span><br><span class="line"><span class="comment">// 定义Paginate，让它继承Page和PerPage</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Paginate</span></span>: Page + PerPage &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_skip_page</span></span>(&amp;<span class="keyword">self</span>, num: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Skip Page: &#123;:?&#125;&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为所有拥有Page和PerPage行为的类型T实现Paginate</span></span><br><span class="line"><span class="comment">// 不用修改已有代码，so方便!!!!!!!!!!</span></span><br><span class="line"><span class="keyword">impl</span> &lt;T: Page + PerPage&gt;Paginate <span class="keyword">for</span> T &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> my_paginate = MyPaginate&#123;page: <span class="number">1</span>&#125;;</span><br><span class="line">    my_paginate.set_page(<span class="number">2</span>);      <span class="comment">// Page Default: 1</span></span><br><span class="line">    my_paginate.set_perpage(<span class="number">100</span>);  <span class="comment">//Per Page default: 10</span></span><br><span class="line">    <span class="comment">// MyPaginate实现了Paginate，否则报错</span></span><br><span class="line">    <span class="comment">// error[E0599]: no method named `set_skip_page`</span></span><br><span class="line">    <span class="comment">// found for struct `MyPaginate` in the current scope</span></span><br><span class="line">    my_paginate.set_skip_page(<span class="number">12</span>);  <span class="comment">// Skip Page: 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trait继承也可以用于扩展标准库中的方法。</p>
<h5 id="4-2-泛型约束"><a href="#4-2-泛型约束" class="headerlink" title="4.2 泛型约束"></a>4.2 泛型约束</h5><p>使用泛型编程时，很多情况下的行为并不是针对所有类型都实现的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/01/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Henry Xue">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haocoder">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/01/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">数据复制技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-01 18:45:33" itemprop="dateCreated datePublished" datetime="2020-11-01T18:45:33+08:00">2020-11-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数据复制主要是通过互联网络在多台机器上保存相同数据的副本。通过数据复制可以得到：</p>
<ul>
<li>使数据在地理位置上更接近用户，<strong>降低用户访问延迟</strong></li>
<li>当部分组件出现故障，系统依然可以继续提供服务，从而<strong>提高可用性</strong></li>
<li>扩展至多台机器以同时提供数据访问服务，从而<strong>提高读吞吐量</strong></li>
</ul>
<p>复制过程中可能会出现各种故障，以及该如何处理这些故障。</p>
<h3 id="三种数据复制方法："><a href="#三种数据复制方法：" class="headerlink" title="三种数据复制方法："></a>三种数据复制方法：</h3><p>几乎所有的分布式数据库都使用以下三种方法的某一种，以及选择同步复制或异步复制策略</p>
<ul>
<li>主从复制</li>
<li>多主节点复制</li>
<li>无主节点复制</li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>每个保存数据库完整数据集的节点称为副本。这里先假设单台机器可以保存整个数据集<strong>如何确保所有副本之间的数据是一致的？</strong><br><strong>主从复制</strong>：基于主节点的复制，原理如下：</p>
<ol>
<li>指定某一个副本为主副本（或称为主节点）。用户的写请求首先发送给主副本，主副本首先将数据写入本地存储系统</li>
<li>其他副本全称为从副本（或称为从节点）。主节点将数据更改作为复制的日志或更改流发送给所有从副本。每个从副本获得更改日志之后将其应用到本地，且严格保持与主副本相同的写入顺序。</li>
<li>客户端可以从主节点或从节点查询数据</li>
</ol>
<p><strong>只有主副本可以接受客户端的写请求，所有副本都可以接受读请求</strong></p>
<h4 id="同步复制与异步复制策略"><a href="#同步复制与异步复制策略" class="headerlink" title="同步复制与异步复制策略"></a>同步复制与异步复制策略</h4><p>对于关系数据库系统，同步或异步复制通常是一个可配置的选项。如图5-2，基于主节点(Leader-based replication)的复制，从节点1(Follower1)是同步复制，主节点需要等待从节点1确认完成了写入，然后才会向用户响应写入完成；从节点2是异步复制，主节点不用等待确认写入完成。<br><img src="https://vipkshttps9.wiz.cn/ks/note/view/9ba27eda-0c0a-45c2-b2aa-41ebc99df5a1/64d4faf1-4eb8-4c9c-a57b-7d3f942c120d/index_files/691507468.png" alt="主从复制"></p>
<h5 id="同步复制的优点："><a href="#同步复制的优点：" class="headerlink" title="同步复制的优点："></a>同步复制的优点：</h5><p> 一旦向用户确认写入完成，即可保证与主节点的数据一致，万一主节点发生故障，可以继续从从节点访问最新数据</p>
<h5 id="同步复制的缺点："><a href="#同步复制的缺点：" class="headerlink" title="同步复制的缺点："></a>同步复制的缺点：</h5><p>如果同步的从节点无法完成确认（发生故障，网络故障），写入就不能视为成功，主节点会阻塞后续所有写入请求，直到同步副本完成确认<br>通常采用同步复制时，只有一个从节点是同步的，其它的都是异步复制模式，一旦同步的从节点不可用，则选一个异步的从节点提升为同步模式。</p>
<h4 id="新增从节点"><a href="#新增从节点" class="headerlink" title="新增从节点"></a>新增从节点</h4><p>当系统需要新增从节点来提供容错能力，或替换失败的副本时，<strong>如何确保新的从节点和主节点保持数据一致？</strong><br>在不停机、数据服务不中断的前提下完成新增从节点的数据同步操作，逻辑上的主要操作步骤如下：</p>
<ol>
<li>在某个时间点对主节点数据产生一个一致性快照，避免长时间锁定数据库。MySQL有第三方备份工具innobackupex</li>
<li>将此快照拷贝到新的从节点</li>
<li>从节点连接到主节点，并请求快照点之后所发生的数据更改日志。快照与系统复制日志的某个确定位置相关联，这个位置在PG中称为“log sequence number(日志序列号），MySQL中称为”binlog coordinates”</li>
<li>获得日志之后，从节点来应用这些快照点之后所有的数据变更，这个过程称为<strong>追赶</strong>。接下来，它可以继续处理主节点上新的数据变化。并重复步骤1~4。具体的详细步骤和操作因数据库系统而异。</li>
</ol>
<h4 id="处理节点失效"><a href="#处理节点失效" class="headerlink" title="处理节点失效"></a>处理节点失效</h4><p><strong>如何通过主从复制技术实现系统高可用呢？</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Henry Xue</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry Xue</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">35k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">32 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
