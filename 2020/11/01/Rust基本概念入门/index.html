<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="语句与表达式1234567891011fn main() &amp;#123;    pub fn answer() -&gt;() &amp;#123;        let a &#x3D; 40;        let b &#x3D; 2;        assert_eq!(sum(a,b), 42);    &amp;#125;    pub fn sum(a: i32, b: i32) -&gt; i32 &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust基础概念入门">
<meta property="og:url" content="http://example.com/2020/11/01/Rust%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="haocoder">
<meta property="og:description" content="语句与表达式1234567891011fn main() &amp;#123;    pub fn answer() -&gt;() &amp;#123;        let a &#x3D; 40;        let b &#x3D; 2;        assert_eq!(sum(a,b), 42);    &amp;#125;    pub fn sum(a: i32, b: i32) -&gt; i32 &amp;#123;">
<meta property="og:locale">
<meta property="article:published_time" content="2020-11-01T11:08:09.322Z">
<meta property="article:modified_time" content="2020-11-01T11:08:09.323Z">
<meta property="article:author" content="Henry Xue">
<meta property="article:tag" content="语句表达式">
<meta property="article:tag" content="trait与抽象">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/11/01/Rust%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Rust基础概念入门 | haocoder</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">haocoder</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/01/Rust%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Henry Xue">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="haocoder">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Rust基础概念入门
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-01 19:08:09" itemprop="dateCreated datePublished" datetime="2020-11-01T19:08:09+08:00">2020-11-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Rust%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">Rust编程语言</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>24k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>22 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="语句与表达式"><a href="#语句与表达式" class="headerlink" title="语句与表达式"></a>语句与表达式</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">answer</span></span>() -&gt;() &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(sum(a,b), <span class="number">42</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        a + b</span><br><span class="line">    &#125;</span><br><span class="line">    answer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="变量与绑定"><a href="#变量与绑定" class="headerlink" title="变量与绑定"></a>变量与绑定</h3><h4 id="位置表达式-左值-与值表达式-右值"><a href="#位置表达式-左值-与值表达式-右值" class="headerlink" title="位置表达式(左值)与值表达式(右值)"></a>位置表达式(左值)与值表达式(右值)</h4><p>位置表达式就是表示内存位置的表达式，有以下几类：</p>
<ul>
<li>本地变量</li>
<li>静态变量</li>
<li>解引用（*expr)</li>
<li>数组索引</li>
<li>字段引用(expr.field)</li>
<li>位置表达式组合</li>
</ul>
<p>通过位置表达式可以对某个数据单元的内存进行读写。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">temp</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> _x = &amp;temp();</span><br><span class="line">    <span class="keyword">let</span> _y = temp();</span><br><span class="line">      <span class="comment">// temp()调用是一个值表达式，不能出现在位置上下文中</span></span><br><span class="line">    temp() = *_x;   <span class="comment">// error[E0070]: invalid left-hand side of assignment</span></span><br><span class="line">    temp() = _y     <span class="comment">// error[E0070]: invalid left-hand side of assignment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="不可变绑定与可变绑定"><a href="#不可变绑定与可变绑定" class="headerlink" title="不可变绑定与可变绑定"></a>不可变绑定与可变绑定</h4><p>使用let关键字声明的位置表达式默认是不可变的，为不可变绑定，即值不能修改。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;  <span class="comment">// immutable</span></span><br><span class="line">    <span class="comment">//a = 2;      // error[E0384]: cannot assign twice to immutable variable `a`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="number">2</span>; <span class="comment">// mutable</span></span><br><span class="line">    b = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="所有权和引用"><a href="#所有权和引用" class="headerlink" title="所有权和引用"></a>所有权和引用</h4><p>当位置表达式出现在值上下文中（比如赋值运算符右侧），该位置表达式将会把内存地址转移给另外一个位置表达式，这其实就是所有权的转移。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> place1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> other = place1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, other);      <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, place1);        <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">    other = <span class="string">&quot;mm&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, other);        <span class="comment">// &quot;mm&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, place1);        <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>place1是一个位置表达式，在<code>let other = place1;</code>中出现在赋值运算符右侧，即一个值上下文内，所以place1会将内存地址转移给other.</p>
<p>在日常开发中，有时候不需要转移所有权，Rust提供了**引用操作符(&amp;)**，可以直接获取表达式的存储单元地址，即内存地址。可以通过该内存地址进行读取。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];          <span class="comment">// 固定长度数组</span></span><br><span class="line">    <span class="keyword">let</span> b = &amp;a;                 <span class="comment">// 取a的地址，不会有所有权转移</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, b);        <span class="comment">// 0x7ffd5114eeb4</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];    <span class="comment">// 动态数组</span></span><br><span class="line">    <span class="keyword">let</span> d = &amp;<span class="keyword">mut</span> c;             <span class="comment">// 获取c的可变引用</span></span><br><span class="line">    d.push(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, d);        <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">      <span class="comment">// 字面量42本身属于值表达式，通过引用操作符，相当于值表达式在位置上下文中进行求值</span></span><br><span class="line">      <span class="comment">// 所以编译器会为&amp;42创建一个临时值</span></span><br><span class="line">    <span class="keyword">let</span> e = &amp;<span class="number">42</span>;                       </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, *e);       <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e);        <span class="comment">// 42</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, e);        <span class="comment">// 0x55c6ad23d0dc</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, *e);       <span class="comment">// error[E0277]: the trait bound `&#123;integer&#125;: std::fmt::Pointer` is not satisfied</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">42</span>, *e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数与闭包"><a href="#函数与闭包" class="headerlink" title="函数与闭包"></a>函数与闭包</h3><p><strong>main函数是程序的入口</strong>,对于二进制可执行文件来说，main函数必不可少，但是对于库函数来说，main函数就没那么必要了。</p>
<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>函数通过关键字<strong>fn</strong>来定义。</p>
<h4 id="作用域与生命周期"><a href="#作用域与生命周期" class="headerlink" title="作用域与生命周期"></a>作用域与生命周期</h4><p>Rust语言的作用域是静态作用域，即词法作用域(Lexical Scope）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="comment">// 连续用let定义同名变量的做法叫变量遮蔽(Variable Shadow)</span></span><br><span class="line">    <span class="keyword">let</span> v = <span class="string">&quot;hello rust&quot;</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello rust&quot;</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开辟一个新的词法作用域,与外部作用域独立</span></span><br><span class="line">        <span class="keyword">let</span> v = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// thread &#x27;main&#x27; panicked at &#x27;assertion failed: `(left == right)`</span></span><br><span class="line">    <span class="comment">// assert_eq!(v, &quot;hello world&quot;);</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(v, <span class="string">&quot;hello rust&quot;</span>);   <span class="comment">// success</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><strong>在Rust中，函数为一等公民，这意味着，函数自身就可以作为函数的参数或返回值使用</strong>。</p>
<h5 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数fn有三个参数op, a, b</span></span><br><span class="line"><span class="comment">// op的类型是个函数，其签名为fn(i32,i32)-&gt;i32</span></span><br><span class="line"><span class="comment">// a，b的类型为i32</span></span><br><span class="line"><span class="comment">// fn的返回值类型为i32</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">math</span></span>(op: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>, a: <span class="built_in">i32</span>, b : <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类型为fn(i32, i32) -&gt; i32</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// a + b; // 返回单元类型()</span></span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类型为fn(i32, i32) -&gt; i32</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">product</span></span>(a: <span class="built_in">i32</span>, b: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    a * b</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(math(sum, a, b), <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(math(product, a, b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数签名fn()-&gt;bool</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_true</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 返回类型为fn()-&gt;bool</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">true_marker</span></span>() -&gt; <span class="function"><span class="keyword">fn</span></span>() -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    is_true     <span class="comment">// 将is_true函数指针返回，即可以将函数名作为函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// true_marker()调用返回is_true函数指针,然后再调用is_true函数</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(true_marker()(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CTFE机制"><a href="#CTFE机制" class="headerlink" title="CTFE机制"></a>CTFE机制</h4><p>Rust编译器也可以像C++或D语言那样，拥有<strong>编译时函数执行(Compile-Time Function Execution, CTFE)的能力</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const fn强制编译器在编译期执行函数</span></span><br><span class="line"><span class="comment">// 关键字const一般用于定义全局常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">init_len</span></span>() -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 初始化初始值为0，长度为N的数组，N由init_len()在编译期求值而来</span></span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">0</span>; init_len()];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);      <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Rust中的CTFE是由miri来执行的，miri是一个MIR解释器</strong>。</p>
<p>Rust编译器目前可以支持的常量表达式有：字面量、元组、数组、字段结构体、枚举、只包含单行代码的块表达式、范围等。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包也叫匿名函数，闭包有以下特点：</p>
<ul>
<li>可以像函数一样被调用</li>
<li>可以捕获上下文环境中的自由变量</li>
<li>可以自动推断输入和返回的类型</li>
</ul>
<p>C++中的lambda表达式会返回一个闭包，也可以被调用，捕获变量、自动推断类型</p>
<p>闭包调用和函数调用很像，但是闭包和函数有一个重要的区别，<strong>闭包可以捕获外部变量，而函数不可以</strong>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> out = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// error[E0434]: can&#x27;t capture dynamic environment in a fn item</span></span><br><span class="line">    <span class="comment">// 在函数内部使用外部定义的变量out编译器会报错，可以使用闭包来代替</span></span><br><span class="line">    <span class="comment">// fn add(i: i32, j: i32) -&gt; i32 &#123; i + j + out &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(i: <span class="built_in">i32</span>,j: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + j &#125;</span><br><span class="line">    <span class="keyword">let</span> closure_annotated = |i: <span class="built_in">i32</span>, j: <span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="comment">// 定义闭包，可以使用外部定义的变量out</span></span><br><span class="line">        i + j + out</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 定义但没有使用会报错，因为定义闭包时没有指定参数和返回值类型，编译器无法推导类型，但是如果闭包被调用了，可以通过实参类型来推导</span></span><br><span class="line">    <span class="comment">// error[E0282]: type annotations needed</span></span><br><span class="line">    <span class="comment">// The compiler could not infer a type and asked for a type annotation.</span></span><br><span class="line">    <span class="keyword">let</span> closure_inferred = |i, j| i +j + out;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>, add(i, j));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_annotated(i, j));</span><br><span class="line">    <span class="comment">// 调用closure_inferred，传递i,j参数会告诉编译器更多信息推到类型</span></span><br><span class="line">    <span class="comment">// 否则只是单独定义closure_inferred，则会编译错误</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">45</span>, closure_inferred(i, j));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, closure_inferred(i, j))     <span class="comment">//45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包也可以作为函数参数和返回值，但使用起来略有区别</p>
<p><strong>Rust中闭包实际上就是由一个匿名结构体和trait来组合实现的。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包作为参数的情况</span></span><br><span class="line"><span class="comment">// 参数op是泛型类型F， F接受Fn()-&gt;i32 trait的限定</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">closure_math</span></span>&lt;F: <span class="built_in">Fn</span>()-&gt;<span class="built_in">i32</span>&gt;(op: F) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    op()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 调用closure_math时传入闭包||a+b,该闭包实现了Fn()-&gt;i32</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(closure_math(|| a + b), <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 调用closure_math传入闭包||a*b,该闭包实现了Fn()-&gt;i32</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(closure_math(|| a * b), <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>闭包同样也可以作为返回值</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包作为返回值的情况</span></span><br><span class="line"><span class="comment">// 使用impl Fn(i32)-&gt;i32作为函数返回值,它表示实现了Fn(i32)-&gt;i32的类型</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">two_times_impl</span></span>() -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 使用move返回闭包，因为闭包默认按照引用捕获变量</span></span><br><span class="line">    <span class="comment">// 如果不使用move, 如果闭包的生命周期比函数的长，</span></span><br><span class="line">    <span class="comment">// 则对变量i的引用可能变成悬垂指针</span></span><br><span class="line">    <span class="comment">// 在定义闭包时并不知道具体闭包的类型，因为变量</span></span><br><span class="line">    <span class="comment">// j的类型不知道</span></span><br><span class="line">    <span class="keyword">move</span> |j| j * i</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = two_times_impl();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result(<span class="number">2</span>), <span class="number">4</span>); <span class="comment">// 2最为闭包的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>条件语句和循环语句在Rust中叫做<strong>流程控制表达式</strong>。而表达式一定会有值。所以if表达式的所有分支必须返回同一个类型的值才可以。这也是Rust没有三元操作符?:的原因。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">1</span>..<span class="number">20</span> &#123;        <span class="comment">// 1..20是一个Range类型，它是一个迭代器</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">15</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;fizzbuzz&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;fizz&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> n % <span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;buzz&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="match表达式与模式匹配"><a href="#match表达式与模式匹配" class="headerlink" title="match表达式与模式匹配"></a>match表达式与模式匹配</h4><p>Rust提供了match表达式，优点类似于其它编程语言中的switch或case语句</p>
<p>match分支使用了模式匹配(Pattern Matching)技术。在Rust语言中，match分支左边就是模式，右边就是执行代码。模式匹配也是一个表达式，所有分支必须返回同一类型，但是左侧的模式可以不同。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">match</span> number &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Origin&quot;</span>),    <span class="comment">//  单值模式</span></span><br><span class="line">        <span class="comment">// 范围模式,warning: `...` range patterns are deprecated</span></span><br><span class="line">        <span class="comment">// use `..=` for an inclusive range</span></span><br><span class="line">        <span class="comment">// 1...3 =&gt; println!(&quot;All&quot;),</span></span><br><span class="line">        <span class="number">1</span>..= <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;All&quot;</span>),</span><br><span class="line">        |<span class="number">5</span>|<span class="number">7</span>|<span class="number">13</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Bad Luck&quot;</span>),    <span class="comment">// 模式为多个值</span></span><br><span class="line">        n @ <span class="number">42</span> =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Answer is &#123;&#125;&quot;</span>, n),  <span class="comment">// 绑定模式，使用操作符@将模式中的值绑定给一个变量</span></span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Common&quot;</span>),  <span class="comment">// _ 通配符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="if-let和while-let表达式"><a href="#if-let和while-let表达式" class="headerlink" title="if let和while let表达式"></a>if let和while let表达式</h4><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="1-布尔类型"><a href="#1-布尔类型" class="headerlink" title="1. 布尔类型"></a>1. 布尔类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">bool</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 比较操作会产生bool类型</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">1</span> &#123; <span class="built_in">println!</span>(<span class="string">&quot;x is bigger than 1&quot;</span>)&#125;;</span><br><span class="line">    <span class="comment">// 通过as操作符将bool类型转换为数字0和1，</span></span><br><span class="line">    <span class="comment">// Rust不支持将数字转换为bool类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(x <span class="keyword">as</span> <span class="built_in">i32</span>, <span class="number">1</span>);   <span class="comment">// &#x27;assertion failed: `(left == right)`</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(y <span class="keyword">as</span> <span class="built_in">i32</span> ,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-基本数字类型"><a href="#2-基本数字类型" class="headerlink" title="2. 基本数字类型"></a>2. 基本数字类型</h4><ul>
<li>固定大小类型：无符号整数和有符号整数</li>
<li>动态大小类型: usize, isize</li>
<li>浮点数类型： f32, f64</li>
</ul>
<h4 id="3-字符类型"><a href="#3-字符类型" class="headerlink" title="3. 字符类型"></a>3. 字符类型</h4><p>在Rust中，使用单引号来定义字符(Char)类型。 字符类型代表的是一个Unicode标量值，每个字符占4个字节。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="string">&#x27;U&#x27;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;\x2A&#x27;</span>,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="string">&#x27;\x25&#x27;</span>,<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-数组类型"><a href="#4-数组类型" class="headerlink" title="4. 数组类型"></a>4. 数组类型</h4><p>数组Array是Rust内建的原始集合类型，数组的特点为：</p>
<ul>
<li>数组大小固定</li>
<li>元素均为同类型</li>
<li>默认不可变</li>
</ul>
<p>数组的类型签名为[T;N], T代表数组中元素类型，N代表数组的长度，是一个编译期常量。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">3</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// 数组类型[i32; 3]</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mut_arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">1</span>, mut_arr[<span class="number">0</span>]);</span><br><span class="line">    mut_arr[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, mut_arr);  <span class="comment">// [3, 2, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);      <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="keyword">let</span> init_arr = [<span class="number">0</span>; <span class="number">10</span>];  <span class="comment">// 初始值为0且长度为10的数组</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, init_arr[<span class="number">5</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">10</span>, init_arr.len());</span><br><span class="line">   <span class="comment">// println!(&quot;&#123;:?&#125;&quot;, arr[5]);       // index out of bounds: the len is 3 but the index is 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-范围类型"><a href="#5-范围类型" class="headerlink" title="5. 范围类型"></a>5. 范围类型</h4><p>Rust内置了范围(Range)类型，包括<strong>左闭右开</strong>和<strong>全闭</strong>两种区间。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..<span class="number">5</span>),  std::ops::Range&#123; start: <span class="number">1</span>, end: <span class="number">5</span>&#125;); <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::ops::Range&#123; start: <span class="number">1</span>, end: <span class="number">3</span>&#125;);  <span class="comment">// 1..3</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((<span class="number">1</span>..=<span class="number">5</span>), std::ops::RangeInclusive::new(<span class="number">1</span>,<span class="number">5</span>)); <span class="comment">// 全闭</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, std::ops::RangeInclusive::new(<span class="number">1</span>,<span class="number">5</span>));  <span class="comment">// 1..=5</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>, (<span class="number">3</span>..<span class="number">6</span>).sum());  <span class="comment">// 范围自带方法sum()</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span>+<span class="number">6</span>, (<span class="number">3</span>..=<span class="number">6</span>).sum());</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">5</span>) &#123;    <span class="comment">// 每个范围都是一个迭代器</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, i); <span class="comment">// 1,2,3,4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">1</span>..=<span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, i);  <span class="comment">// 1, 2,3,4,5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-切片类型"><a href="#6-切片类型" class="headerlink" title="6. 切片类型"></a>6. 切片类型</h4><p>切片(Slice)类型是对一个数组的引用片段，有利于安全有效的访问数组的一部分，而不需要拷贝。理论上讲，切片引用的是已经存在的变量。在底层，切片代表一个指向数组起始位置的指针和数组长度。用[T]类型表示连续序列，那么切片类型就是&amp;[T]和&amp;mut[T]。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 固定长度数组</span></span><br><span class="line">    <span class="keyword">let</span> arr: [<span class="built_in">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="comment">// &amp;arr: 引用数组arr,产生一个切片&amp;arr</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr, &amp;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">// &amp;arr[1..]：对数组进行切割</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr[<span class="number">1</span>..], [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line">    <span class="comment">// const fn方法len(),获取切片长度</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr.len(), &amp;<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// const fn方法is_empty()，判断切片是否为空</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;arr.is_empty(), &amp;<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// &amp;mut 定义可变切片</span></span><br><span class="line">    <span class="keyword">let</span> arr = &amp;<span class="keyword">mut</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, arr);      <span class="comment">// [1,2,3]</span></span><br><span class="line">    arr[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">//assert_eq!(arr, [1,7,3]); //error[E0277]: can&#x27;t compare `&amp;mut [&#123;integer&#125;; 3]` with `[&#123;integer&#125;; 3]`</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(arr, &amp;[<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// vec!定义动态数组</span></span><br><span class="line">    <span class="keyword">let</span> vec = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, vec);      <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="comment">// &amp;vec是切片类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;vec, &amp;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// &amp;vec[..]是对切片&amp;vec进行切割获得结果序列[1,2,3]</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(&amp;vec[..], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;vec);     <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;vec[<span class="number">1</span>..]); <span class="comment">// [2, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-str字符串类型"><a href="#7-str字符串类型" class="headerlink" title="7. str字符串类型"></a>7. str字符串类型</h4><p>Rust的字符串分为两种类型：</p>
<ul>
<li>str字符串： 固定长度，不可随便改变其长度</li>
<li>String字符串：可增长字符串，可以随意改变其长度</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 定义字符串字面量truth,字符串字面量也属于str类型</span></span><br><span class="line">    <span class="comment">// truth是静态生命周期字符串&amp;&#x27;static str</span></span><br><span class="line">    <span class="keyword">let</span> truth: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span> = <span class="string">&quot;Rust是一门优雅的语言&quot;</span>;</span><br><span class="line">    <span class="comment">// str字符串类型分为两部分</span></span><br><span class="line">    <span class="comment">// 1. 指向字符串序列的指针</span></span><br><span class="line">    <span class="keyword">let</span> ptr = truth.as_ptr();</span><br><span class="line">    <span class="comment">// 2. 字符串长度</span></span><br><span class="line">    <span class="keyword">let</span> len = truth.len();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">28</span>,len);</span><br><span class="line">    <span class="comment">// s是一个str字符串，在unsafe块中执行字节序列到str字符串的转换过程</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// Rust中的字符串本质上是一段有效的UTF8字节序列</span></span><br><span class="line">        <span class="comment">// 将字节序列转换为切片类型&amp;[u8]</span></span><br><span class="line">        <span class="keyword">let</span> slice = std::slice::from_raw_parts(ptr, len);</span><br><span class="line">        <span class="comment">// 将切片slice转换为str字符串</span></span><br><span class="line">        std::<span class="built_in">str</span>::from_utf8(slice)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(s, <span class="literal">Ok</span>(truth));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-原生指针"><a href="#8-原生指针" class="headerlink" title="8. 原生指针"></a>8. 原生指针</h4><p>将表示内存地址的类型称为<strong>指针</strong>。Rust提供的多种类型指针：</p>
<ul>
<li>引用(Reference): 本质上是一种非空指针，属于<strong>Safe Rust</strong>，即编译器会对引用进行借用检查，以确保内存安全和类型安全</li>
<li>原生指针(Raw Pointer)： 属于<strong>Unsafe Rust</strong>，直接使用原生指针不安全，因为它可能指向一个Null，或者一个已被释放的内存区域，需要程序员自己保证安全。Rust支持两种原生指针：不可变原生指针<code> *const T</code>和可变原生指针<code>*mut T</code> 。</li>
<li>函数指针(fn Pointer)</li>
<li>智能指针(Smart Pointer)</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生指针示例</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">10</span>;         <span class="comment">// x是一个可变绑定</span></span><br><span class="line">    <span class="comment">// 通过as操作符将&amp;mut x可变引用转换为*mut i32可变原生指针ptr_x</span></span><br><span class="line">    <span class="keyword">let</span> ptr_x = &amp;<span class="keyword">mut</span> x <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="comment">// 在堆内存上存储数字20</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 将引用&amp;*y 转换为*const i32不可变原生指针ptr_y</span></span><br><span class="line">    <span class="keyword">let</span> ptr_y = &amp;*y <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        *ptr_x += *ptr_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-never类型"><a href="#9-never类型" class="headerlink" title="9. never类型"></a>9. never类型</h4><p>Rust提供了一种特殊数据类型，never类型，即！。该类型用于表示永远不可能有返回值的计算类型，比如线程退出时，就不可能有返回值。因为Rust是一种类型安全的语言，所以也需要将这种情况纳入类型系统中进行统一管理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// never类型示例</span></span><br><span class="line"><span class="meta">#![feature(never_type)]</span>  <span class="comment">// never类型属于实验类型，在Nightly版本下使用该特性</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="comment">// x是never类型</span></span><br><span class="line">    <span class="keyword">let</span> x: ! = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>  <span class="comment">// 将123返回，x永远不会被赋值</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num : <span class="built_in">Option</span>&lt;<span class="built_in">u32</span>&gt; = <span class="literal">Some</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// match匹配表达式要求所有分支必须返回相同类型</span></span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="comment">// 该分支返回u32类型，编译器没有报错的原因是never类型可以强制转换为其他任何类型</span></span><br><span class="line">        <span class="literal">Some</span>(num) =&gt; num,</span><br><span class="line">        <span class="comment">// panic!宏会返回never类型</span></span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Nothing&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>Rust提供了四种复合数据类型：</p>
<ul>
<li>元组（Tuple)</li>
<li>结构体（Struct）</li>
<li>枚举体（Enum)</li>
<li>联合体（Union)</li>
</ul>
<p>这四种数据类型都是异构数据结构，意味着可以使用它们将多种类型构建为统一的数据类型。</p>
<h4 id="1-元组"><a href="#1-元组" class="headerlink" title="1. 元组"></a>1. 元组</h4><p>元组(Tuple)是一种异构有限序列，形如（T, U, M, N)，异构表示元组内的元素类型可以不同；有限序列指元组有固定的长度</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组示例</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">move_coords</span></span>(x: (<span class="built_in">i32</span>, <span class="built_in">i32</span>)) -&gt; (<span class="built_in">i32</span>, <span class="built_in">i32</span>) &#123;</span><br><span class="line">    (x.<span class="number">0</span> + <span class="number">1</span>, x.<span class="number">1</span> + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// tuple是类型为(&amp;&#x27;static str, i32, char)的元组</span></span><br><span class="line">    <span class="keyword">let</span> tuple: (&amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>, <span class="built_in">i32</span>, <span class="built_in">char</span>) = (<span class="string">&quot;hello&quot;</span>, <span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="comment">// 可以通过索引来获取元组内元素的值</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(tuple.<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(tuple.<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> coords = (<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> result = move_coords(coords);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(result, (<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    <span class="comment">// let支持模式匹配，所以可以用来解构元组</span></span><br><span class="line">    <span class="keyword">let</span> (x, y) = move_coords(coords);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-结构体"><a href="#2-结构体" class="headerlink" title="2. 结构体"></a>2. 结构体</h4><p>Rust提供三种结构体：</p>
<ul>
<li>具名结构体（Named-Field Struct)</li>
<li>元组结构体（Tuple-Like Struct)</li>
<li>单元结构体（Unit-Like Struct)</li>
</ul>
<h5 id="具名结构体"><a href="#具名结构体" class="headerlink" title="具名结构体"></a>具名结构体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具名结构体示例</span></span><br><span class="line"><span class="comment">// 该属性可以让结构体自动实现debug trait</span></span><br><span class="line"><span class="comment">// 和PartialEq trait，它们的功能是允许对结构体</span></span><br><span class="line"><span class="comment">// 实体进行打印和比较</span></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="comment">// Rust具名结构体是面向对象思想的一种体现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span> &#123;</span><br><span class="line">    <span class="comment">// 字段格式：name: type</span></span><br><span class="line">    name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>,</span><br><span class="line">    gender: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> People &#123;</span><br><span class="line">    <span class="comment">// 为People结构体实现4个方法</span></span><br><span class="line">    <span class="comment">// 在impl块中定义的函数称为方法，类似于面向对象</span></span><br><span class="line">    <span class="comment">// 不在impl块里定义的函数，就是自由函数</span></span><br><span class="line">    <span class="comment">// new方法类似于面向对象语言中的构造函数</span></span><br><span class="line">    <span class="comment">// new方法参数并没有&amp;self</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>, gender: <span class="built_in">u32</span>)-&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> People&#123;name: name, gender:gender&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数&amp;self代表一个对结构体实例自身的引用</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">name</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;name : &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_name</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, name: &amp;<span class="symbol">&#x27;static</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">gender</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> gender = <span class="keyword">if</span> (<span class="keyword">self</span>.gender == <span class="number">1</span>) &#123;<span class="string">&quot;boy&quot;</span>&#125; <span class="keyword">else</span> &#123;<span class="string">&quot;girl&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;gender:&#123;:?&#125;&quot;</span>, gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用结构体中定义的相关函数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> alex = People::new(<span class="string">&quot;Alex&quot;</span>, <span class="number">1</span>);  <span class="comment">// 创建Peopoe结构体实体</span></span><br><span class="line">    alex.name();            <span class="comment">// name : &quot;Alex&quot;</span></span><br><span class="line">    alex.gender();          <span class="comment">// gender:&quot;boy&quot;</span></span><br><span class="line">    <span class="comment">// 1. binary operation `==` cannot be applied to type `People`</span></span><br><span class="line">    <span class="comment">// 2. `People` doesn&#x27;t implement `Debug`</span></span><br><span class="line">    <span class="comment">// 报以上两个错误，是因为结构体没有实现debug trait和PartialEq trait</span></span><br><span class="line">    <span class="comment">// 可以使用#[derive(Debug, PartialEq)]属性</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(alex, People &#123; name: <span class="string">&quot;Alex&quot;</span>, gender : <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> alice = People::new(<span class="string">&quot;Alice&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    alice.name();          <span class="comment">// name : &quot;Alice&quot;</span></span><br><span class="line">    alice.gender();        <span class="comment">// gender:&quot;girl&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(alice, People &#123;name: <span class="string">&quot;Alice&quot;</span>, gender: <span class="number">0</span>&#125;);</span><br><span class="line">    alice.set_name(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">    alice.name();           <span class="comment">// name : &quot;Rose&quot;</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(alice, People &#123; name: <span class="string">&quot;Rose&quot;</span>, gender: <span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h5><p><strong>特点是，字段没有名称，只有类型</strong>，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组结构体实例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span> (<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);   <span class="comment">// 元组结构体后面要加分号</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> color = Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 元组结构体访问字段方式和元组一样，使用圆点记号按位置索引访问</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(color.<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(color.<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>当一个元组结构体只有一个字段的时候，称之为New Type模型</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New Type模式示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Integer</span></span>(<span class="built_in">u32</span>);   <span class="comment">// 单字段结构体，相当于把u32类型包装成了新的Integer类型</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Int</span></span> = <span class="built_in">i32</span>;        <span class="comment">// type关键字创建类型别名</span></span><br><span class="line"><span class="comment">// New Type模型属于自定义类型，比type关键字创建类型别名更灵活</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> int = Integer(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(int.<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> int: Int = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(int, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="单元结构体"><a href="#单元结构体" class="headerlink" title="单元结构体"></a><strong>单元结构体</strong></h5><p>Rust中可以定义一个没有任何字段的结构体，即单元结构体</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单元结构体示例</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Empty</span></span>;   <span class="comment">// 没有任何字段的结构体,等价于struct Empty &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = Empty;   <span class="comment">// 单元结构体实例就是其本身</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;x);    <span class="comment">// 0x7ffca81056b8</span></span><br><span class="line">    <span class="comment">// x是位置表达式，而它的上下文是值上下文，所以它的内存地址</span></span><br><span class="line">    <span class="comment">// 会移动给新的位置表达式y</span></span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;y);   <span class="comment">// 0x7ffca8105710</span></span><br><span class="line">    <span class="keyword">let</span> z = Empty;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;z);   <span class="comment">// 0x7ffca8105768</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>((..), std::ops::RangeFull);  <span class="comment">// RangeFull表示全范围(..)就是一个单元结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Debug编译模式下，x,y,z是不同的内存地址</p>
</li>
<li><p>在Release编译模式下，x,y,z是相同的内存地址</p>
<p>这证明，在Release编译模式下，单元结构体实例会被优化为同一个对象，而在Debug模式下，不会进行这样的优化。</p>
<p>单元结构体与NewType模式类似，也相当于定义一个新类型，单元结构体一般用于一些特定场景，比如标准库的RangeFull。</p>
</li>
</ul>
<h4 id="3-枚举体"><a href="#3-枚举体" class="headerlink" title="3. 枚举体"></a>3. 枚举体</h4><p>Rust中使用enum关键字定义枚举类型，该类型包含了全部可能的情况，有效防止用户提供无效值。</p>
<p>Rust有三种形式的枚举</p>
<ul>
<li>无参数枚举体</li>
<li>类C枚举体</li>
<li>带参数枚举体</li>
</ul>
<h5 id="无参数枚举"><a href="#无参数枚举" class="headerlink" title="无参数枚举"></a>无参数枚举</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数示例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Number</span></span> &#123;</span><br><span class="line">    <span class="comment">// 三个值，而非类型</span></span><br><span class="line">    Zero,</span><br><span class="line">    One,</span><br><span class="line">    Two,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Number::One;</span><br><span class="line">    <span class="keyword">match</span> a &#123;</span><br><span class="line">        Number::Zero =&gt; <span class="built_in">println!</span>(<span class="string">&quot;0&quot;</span>),</span><br><span class="line">        Number::One =&gt; <span class="built_in">println!</span>(<span class="string">&quot;1&quot;</span>),       <span class="comment">// 1</span></span><br><span class="line">        Number::Two =&gt; <span class="built_in">println!</span>(<span class="string">&quot;2&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="类C枚举体"><a href="#类C枚举体" class="headerlink" title="类C枚举体"></a>类C枚举体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类C枚举体示例</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">    <span class="comment">// 三个枚举值，并且赋值</span></span><br><span class="line">    Red = <span class="number">0xff0000</span>,</span><br><span class="line">    Green = <span class="number">0x00ff00</span>,</span><br><span class="line">    Blue = <span class="number">0x000ff</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;roses are #&#123;:06x&#125;&quot;</span>, Color::Red <span class="keyword">as</span> <span class="built_in">i32</span>);  <span class="comment">//roses are #ff0000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="带参数枚举体"><a href="#带参数枚举体" class="headerlink" title="带参数枚举体"></a>带参数枚举体</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带参数枚举体示例</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    <span class="comment">// 枚举值携带了类型参数，这样的枚举值本质上属于函数指针</span></span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// IpAddr::V4是类型为fn(u8,u8,u8,u8) -&gt; IpAddr的函数指针</span></span><br><span class="line">    <span class="keyword">let</span> x : <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>,<span class="built_in">u8</span>) -&gt; IpAddr = IpAddr::V4;</span><br><span class="line">    <span class="keyword">let</span> y : <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">String</span>) -&gt;IpAddr = IpAddr::V6;</span><br><span class="line">    <span class="comment">// 像使用函数调用一样使用带参数枚举</span></span><br><span class="line">    <span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, home);     <span class="comment">// V4(127, 0, 0, 1)</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<p><strong>枚举体在Rust中属于非常重要的类型之一</strong>，一方面为编程提供了很多方便，另一方面，保证了Rust中避免出现空指针。</p>
<h3 id="常用集合类型"><a href="#常用集合类型" class="headerlink" title="常用集合类型"></a>常用集合类型</h3><p>在Rust标准库<code>std::collections</code>集合模块有4中通用集合类型：</p>
<ul>
<li>线性序列：向量(Vec)，双端队列(VecDeque)， 链表(LinkedList)</li>
<li>Key-Value映射表：无序哈希表(HashMap)，有序哈希表(BTreeMap)</li>
<li>集合类型： 无序集合（HashSet)，有序集合(BTreeSet)</li>
<li>优先队列：二叉堆（BinaryHeap)</li>
</ul>
<h4 id="线性序列：-向量"><a href="#线性序列：-向量" class="headerlink" title="线性序列： 向量"></a>线性序列： 向量</h4><p>向量也是数组，但是它可以动态增长</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性序列：向量Vec&lt;T&gt;示例</span></span><br><span class="line"><span class="comment">// Vec&lt;T&gt;会被自动引入</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 第一种初始化方法</span></span><br><span class="line">    <span class="comment">// vec!是一个宏，用来创建向量字面量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v1 = <span class="built_in">vec!</span>[];</span><br><span class="line">    v1.push(<span class="number">1</span>);</span><br><span class="line">    v1.push(<span class="number">2</span>);</span><br><span class="line">    v1.push(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(v1[<span class="number">1</span>], <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 第二种初始化方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v2 = <span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">10</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v2);  <span class="comment">// [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line">      <span class="comment">// 第三种初始化方法</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v3 = <span class="built_in">Vec</span>::new();</span><br><span class="line">    v3.push(<span class="number">5</span>);</span><br><span class="line">      <span class="comment">//v3.push(&quot;hello&quot;);  // error[E0308]: mismatched types, expected integer, found `&amp;str`</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, v3);  <span class="comment">// [5]</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>Rust会对向量和数组进行越界检查</p>
<h4 id="线性序列：双端队列"><a href="#线性序列：双端队列" class="headerlink" title="线性序列：双端队列"></a>线性序列：双端队列</h4><p>是一种同时具有队列和栈性质的数据结构，插入和删除操作被限定在队列的两端进行</p>
<p>Rust中VecDeque是基于可增长的RingBuffer算法实现的双端队列</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性序列：双端队列VecDeque&lt;T&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::VecDeque;  <span class="comment">// 引入VecDeque&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> buf = VecDeque::new();</span><br><span class="line">    buf.push_front(<span class="number">1</span>);</span><br><span class="line">    buf.push_front(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">0</span>), <span class="literal">Some</span>(&amp;<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">1</span>), <span class="literal">Some</span>(&amp;<span class="number">1</span>));</span><br><span class="line">    buf.push_back(<span class="number">3</span>);</span><br><span class="line">    buf.push_back(<span class="number">4</span>);</span><br><span class="line">    buf.push_back(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">2</span>), <span class="literal">Some</span>(&amp;<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">assert_eq!</span>(buf.get(<span class="number">3</span>), <span class="literal">Some</span>(&amp;<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线性序列：-链表"><a href="#线性序列：-链表" class="headerlink" title="线性序列： 链表"></a>线性序列： 链表</h4><p>Rust提供了双向链表，允许在任意一端插入或弹出元素。但是通常最好使用Vec或VecDeque，因为它们比链表更加快速，内存访问效率更高，并且可以更好地利用CPU缓存。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线性序列：双向链表LinkedList&lt;T&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::LinkedList;  <span class="comment">// 引入LinkedList&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list1 = LinkedList::new();</span><br><span class="line">    list1.push_back(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> list2 = LinkedList::new();</span><br><span class="line">    list2.push_back(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    list2.push_back(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list2);   <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    list1.append(&amp;<span class="keyword">mut</span> list2);  <span class="comment">// 连接两个链表</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list1);  <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list2);  <span class="comment">// []</span></span><br><span class="line">    list1.pop_front();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list1);  <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    list1.push_front(<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list1);  <span class="comment">// [&#x27;e&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">    list2.push_front(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, list2);  <span class="comment">// [&#x27;f&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h4 id="Key-Value映射表：HashMap和BTreeMap"><a href="#Key-Value映射表：HashMap和BTreeMap" class="headerlink" title="Key-Value映射表：HashMap和BTreeMap"></a>Key-Value映射表：HashMap和BTreeMap</h4><p>Rust集合模块提供了两个key-value哈希映射表：</p>
<ul>
<li>HashMap&lt;k, v&gt;</li>
<li>BTreeMap&lt;k, v&gt;</li>
</ul>
<p>key必须是可哈希的类型，value必须是在编译期已知大小的类型</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Key-Value映射表：HashMap&lt;K,V&gt;和BTreeMap&lt;K,V&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashMap;  <span class="comment">// 引入HashMap</span></span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeMap;  <span class="comment">// 引入BTreeMap</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 创建HashMap和BTreeMap的实例</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> hmap = HashMap::new();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bmap = BTreeMap::new();</span><br><span class="line">    hmap.insert(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    hmap.insert(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    bmap.insert(<span class="number">4</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    bmap.insert(<span class="number">1</span>, <span class="string">&quot;e&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, hmap);  <span class="comment">// &#123;3: &quot;c&quot;, 1: &quot;a&quot;&#125;， key顺序不固定，因为HashMap是无序的</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, bmap);  <span class="comment">// &#123;1: &quot;3&quot;, 4: &quot;a&quot;&#125;， key是有序的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合：-HashSet和BTreeSet"><a href="#集合：-HashSet和BTreeSet" class="headerlink" title="集合： HashSet和BTreeSet"></a>集合： HashSet和BTreeSet</h4><p><code>HashSet&lt;K&gt;</code>和<code>BTreeSet&lt;K&gt;</code>是<code>HashMap&lt;k, v&gt;</code>，<code>BTreeMap&lt;k, v&gt;</code>把value设置为空元组的特定类型，等价于<code>HashMap&lt;k, ()&gt;</code>和 <code>BTreeMap&lt;k, ()&gt;</code></p>
<ul>
<li>集合中元素是唯一的</li>
<li>集合中元素都是可哈希的类型</li>
<li>HashSet是无序的，BTreeMap是有序的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合： HashSet&lt;k&gt;和BTreeSet&lt;K&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::HashSet;</span><br><span class="line"><span class="keyword">use</span> std::collections::BTreeSet;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> hbooks = HashSet::new();  <span class="comment">// 无序</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> bbooks = BTreeSet::new(); <span class="comment">// 有序</span></span><br><span class="line">    hbooks.insert(<span class="string">&quot;A Song of Ice and Fire&quot;</span>);</span><br><span class="line">    hbooks.insert(<span class="string">&quot;The Emerald City&quot;</span>);</span><br><span class="line">    hbooks.insert(<span class="string">&quot;The Odyssey&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> !hbooks.contains(<span class="string">&quot;The Emerald City&quot;</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;we have &#123;&#125; books, but no The Emerald City&quot;</span>, hbooks.len());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 顺序随机</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, hbooks);  <span class="comment">// &#123;&quot;The Odyssey&quot;, &quot;The Emerald City&quot;, &quot;A Song of Ice and Fire&quot;&#125;</span></span><br><span class="line">    bbooks.insert(<span class="string">&quot;A Song of Ice and Fire&quot;</span>);</span><br><span class="line">    bbooks.insert(<span class="string">&quot;The Emerald City&quot;</span>);</span><br><span class="line">    bbooks.insert(<span class="string">&quot;The Odyssey&quot;</span>);</span><br><span class="line">    <span class="comment">// 顺序固定</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, bbooks);  <span class="comment">// &#123;&quot;A Song of Ice and Fire&quot;, &quot;The Emerald City&quot;, &quot;The Odyssey&quot;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h4 id="优先队列：-BinaryHeap"><a href="#优先队列：-BinaryHeap" class="headerlink" title="优先队列： BinaryHeap"></a>优先队列： BinaryHeap</h4><p>Rust提供的优先队列是基于二叉最大堆实现的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先队列：BinaryHeap&lt;T&gt;示例</span></span><br><span class="line"><span class="keyword">use</span> std::collections::BinaryHeap;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> heap = BinaryHeap::new();</span><br><span class="line">    <span class="built_in">assert_eq!</span>(heap.peek(), <span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">93</span>, <span class="number">80</span>, <span class="number">48</span>, <span class="number">53</span>, <span class="number">72</span>, <span class="number">30</span>, <span class="number">18</span>, <span class="number">36</span>, <span class="number">15</span>, <span class="number">35</span>, <span class="number">45</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;i <span class="keyword">in</span> arr.iter() &#123;</span><br><span class="line">        heap.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(heap.peek(), <span class="literal">Some</span>(&amp;<span class="number">93</span>));</span><br><span class="line">    <span class="comment">// [93, 80, 48, 53, 72, 30, 18, 36, 15, 35, 45]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>Rust中的值默认被分配到栈内存，可以通过<code>Box&lt;T&gt;</code>将值装箱(在堆内存中分配)。<code>Box&lt;T&gt;</code>是指向类型为T的堆内存分配值的智能指针。当<code>Box&lt;T&gt;</code>超出作用域范围时，将调用其析构函数，销毁内部对象，并自动释放堆中的内存，可以通过解引用操作符来获取<code>Box&lt;T&gt;</code>中的T。</p>
<p>Rust中提供了很多智能指针类型，这里只介绍<code>Box&lt;T&gt;</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 智能指针：Box&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">        x : <span class="built_in">f64</span>,</span><br><span class="line">        y : <span class="built_in">f64</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> boxed_point = <span class="built_in">Box</span>::new(Point &#123; x :<span class="number">0.0</span>, y: <span class="number">0.0</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> unboxed_point: Point = *boxed_point;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(unboxed_point, Point &#123;x:<span class="number">0.0</span>, y:<span class="number">0.0</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="泛型和trait"><a href="#泛型和trait" class="headerlink" title="泛型和trait"></a>泛型和trait</h3><p><strong>泛型</strong>和<strong>trait</strong>是Rust类型系统中最重要的两个概念。</p>
<p><strong>trait</strong>借鉴了Haskell的Typeclass。trait是Rust实现零成本抽象的基石，它有如下机制：</p>
<ul>
<li>trait是rust唯一的接口抽象方式</li>
<li>可以静态生成，也可以动态调用</li>
<li>可以当做标记类型拥有某些特定行为的“标签”来使用。</li>
</ul>
<p><strong>简单来说，trait是对类型行为的抽象</strong>。</p>
<p>Rust中没有继承的概念，它通过trait将类型和行为明确的进行了区分，充分贯彻了组合优于继承和面向接口编程的编程思想。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// trait示例</span></span><br><span class="line"><span class="comment">// 定义两个结构体Duck,Pig</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Duck</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pig</span></span>;</span><br><span class="line"><span class="comment">// 定义Flay trait</span></span><br><span class="line"><span class="comment">// 在Rust中，trait是唯一的接口抽象方式</span></span><br><span class="line"><span class="comment">// 使用trait可以让不同的类型实现同一种行为，</span></span><br><span class="line"><span class="comment">// 也可以为类型添加新的行为</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fly</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用impl关键字为Duck实现Fly trait</span></span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Duck &#123;</span><br><span class="line">    <span class="comment">// Duck实现fly函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> Fly <span class="keyword">for</span> Pig &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. fly_static是泛型函数</span></span><br><span class="line"><span class="comment">// 2. 泛型参数声明类型为T，表示任何类型</span></span><br><span class="line"><span class="comment">// 3. T:Fly语法形式表示使用Flay trait对泛型T进行行为限制，</span></span><br><span class="line"><span class="comment">// 代表T是实现了Fly trait的类型，或者拥有fly这种行为的类型</span></span><br><span class="line"><span class="comment">// 这种限定在Rust中称为trait限定(trait bound),通过trait限定，</span></span><br><span class="line"><span class="comment">// 限制了fly_static泛型参数的类型范围,如果传入的参数不满足</span></span><br><span class="line"><span class="comment">// 该类型限制，则编译器会报错</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;T: Fly&gt;(s: T) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    s.fly()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数是&amp;Fly类型，&amp;Fly类型是一种动态类型，代表拥有fly行为的类型</span></span><br><span class="line"><span class="comment">// fly_static和fly_dyn的区别是，函数实现内fly方法调用机制不同</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(s: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    s.fly()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pig = Pig;</span><br><span class="line">    <span class="comment">// ::&lt;Pig&gt;表示为泛型函数执行具体的类型</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_static::&lt;Pig&gt;(pig), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">let</span> duck = Duck;</span><br><span class="line">    <span class="comment">// 调用fly_static的这种方式叫静态分发</span></span><br><span class="line">    <span class="comment">// Rust编译器会为fly_static::&lt;Duck&gt;(duck)的调用生成特殊化的代码</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_static::&lt;Duck&gt;(duck), <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// fly_dyn调用属于动态分发，在运行时查找相应类型的方法</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_dyn(&amp;Pig), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(fly_dyn(&amp;Duck), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上例子，Rust的trait完全符合C++之父提出的<strong>零开销原则</strong>：如果你不使用某个抽象，就不用为它付出开销（静态分发）；如果你确实需要使用该抽象，可以保证这是开销最小的使用方式（动态分发）。</p>
<p>Rust中内置了trait，开发者可以通过实现这些trait来扩展自定义类型的行为，比如实现了最常用的Debug trait，就可以拥有在println!宏语句中使用{:?}格式进行打印的行为。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Debug trait</span></span><br><span class="line"><span class="keyword">use</span> std::fmt::*;   <span class="comment">// 引入Debug trait</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x : <span class="built_in">i32</span>,</span><br><span class="line">    y : <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 为Point实现Debug trait</span></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Debug</span> <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter) -&gt; <span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Point &#123;&#123;x:&#123;&#125;, y:&#123;&#125;&#125;&#125;&quot;</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> origin = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The origin is : &#123;:?&#125;&quot;</span>, origin);  <span class="comment">// The origin is : Point &#123;x:0, y:0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Rust中的错误处理是通过返回<code>Result&lt;T, E&gt;</code>类型的方式进行的，<code>Result&lt;T, E&gt;</code>类型是<code>Option&lt;T&gt;</code>类型的升级版本，同样定义在标准库中。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Result&lt;T,E&gt; 源码实现, 表示错误的可能性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">enum Result&lt;T, E&gt; &#123;</span></span><br><span class="line"><span class="comment">    Ok(T),</span></span><br><span class="line"><span class="comment">    Err(E),   // 泛型E代表错误Error</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Result&lt;T,E&gt;使用范例</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Ok</span>(-<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x.is_ok(), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, &amp;<span class="built_in">str</span>&gt; = <span class="literal">Err</span>(<span class="string">&quot;Some error message&quot;</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x.is_ok(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust 2018版本允许main函数返回<code>Result&lt;T, E&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数返回Result&lt;T,E&gt;</span></span><br><span class="line"><span class="comment">// Result&lt;(), std::io::Error&gt;表示函数返回的错误类型为std::io::Error,</span></span><br><span class="line"><span class="comment">// 正确类型为单元类型()</span></span><br><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), std::io::Error&gt;&#123;</span><br><span class="line">    <span class="comment">// ?操作符是一个错误处理语法糖，会在自动出现错误时返回std::io::Error</span></span><br><span class="line">    <span class="keyword">let</span> f = File::open(<span class="string">&quot;bar.txt&quot;</span>)?; <span class="comment">// Error: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;</span></span><br><span class="line">    <span class="literal">Ok</span>(())  <span class="comment">// File::open成功时返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="表达式优先级"><a href="#表达式优先级" class="headerlink" title="表达式优先级"></a>表达式优先级</h3><p>在Rust中，一切皆表达式。</p>
<h3 id="注释与打印"><a href="#注释与打印" class="headerlink" title="注释与打印"></a>注释与打印</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>Rust是一门现代语言。Rust文档的哲学是：<strong>代码即文档，文件即代码</strong>。</p>
<p>Rust支持的注释种类：</p>
<ul>
<li>普通注释<ul>
<li>单行注释 //</li>
<li>多行注释 /* … */</li>
</ul>
</li>
<li>文档注释：内部支持Markdown标记，也支持对文档中的示例代码进行测试，可以用rustdoc工具生成HTML文档<ul>
<li>使用///注释可以生成库文档，一般用于函数或结构体的说明，置于说明对象上方</li>
<li>使用//!也可以生成库文档，一般用于说明整个模块的功能，置于模块文件的头部。</li>
</ul>
</li>
</ul>
<h4 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h4><p>使用println!宏语句进行格式化打印，该宏支持的格式化列表：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// println!打印宏</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">// 1. nothing代表display</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="number">22</span>);    <span class="comment">// 22</span></span><br><span class="line">    <span class="comment">// 2. ?代表Debug</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 22</span></span><br><span class="line">    <span class="comment">// 3. o代表八进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:o&#125;&quot;</span>, <span class="number">22</span>);  <span class="comment">// 26</span></span><br><span class="line">      <span class="comment">// 4. x代表十六进制小写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 16</span></span><br><span class="line">      <span class="comment">// 5. X代表十六进制大写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:X&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 16</span></span><br><span class="line">    <span class="comment">// 6. p代表指针</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, &amp;<span class="number">22</span>);  <span class="comment">// 0x560486d5b004</span></span><br><span class="line">      <span class="comment">// 7. b代表二进制</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:b&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 10110</span></span><br><span class="line">      <span class="comment">// 8. e代表指数小写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:e&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 2.2e1</span></span><br><span class="line">    <span class="comment">// 9. E代表指数大写</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:E&#125;&quot;</span>, <span class="number">22</span>);   <span class="comment">// 2.2E1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%AD%E5%8F%A5%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag"># 语句表达式</a>
              <a href="/tags/trait%E4%B8%8E%E6%8A%BD%E8%B1%A1/" rel="tag"># trait与抽象</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/01/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" rel="prev" title="Rust类型系统">
      <i class="fa fa-chevron-left"></i> Rust类型系统
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">语句与表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E7%BB%91%E5%AE%9A"><span class="nav-number">2.</span> <span class="nav-text">变量与绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%B7%A6%E5%80%BC-%E4%B8%8E%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%8F%B3%E5%80%BC"><span class="nav-number">2.1.</span> <span class="nav-text">位置表达式(左值)与值表达式(右值)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8F%AF%E5%8F%98%E7%BB%91%E5%AE%9A"><span class="nav-number">2.2.</span> <span class="nav-text">不可变绑定与可变绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text">所有权和引用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">函数与闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.</span> <span class="nav-text">函数定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.2.</span> <span class="nav-text">作用域与生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-number">3.3.</span> <span class="nav-text">函数指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">函数作为参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">3.3.2.</span> <span class="nav-text">函数作为返回值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTFE%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">CTFE机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.5.</span> <span class="nav-text">闭包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#match%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">4.1.</span> <span class="nav-text">match表达式与模式匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if-let%E5%92%8Cwhile-let%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">if let和while let表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">1. 布尔类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">2. 基本数字类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">3. 字符类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.</span> <span class="nav-text">4. 数组类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%8C%83%E5%9B%B4%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.5.</span> <span class="nav-text">5. 范围类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%88%87%E7%89%87%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.6.</span> <span class="nav-text">6. 切片类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-str%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.7.</span> <span class="nav-text">7. str字符串类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%8E%9F%E7%94%9F%E6%8C%87%E9%92%88"><span class="nav-number">5.8.</span> <span class="nav-text">8. 原生指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-never%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.9.</span> <span class="nav-text">9. never类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.</span> <span class="nav-text">复合数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%85%83%E7%BB%84"><span class="nav-number">6.1.</span> <span class="nav-text">1. 元组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.2.</span> <span class="nav-text">2. 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.2.1.</span> <span class="nav-text">具名结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.2.2.</span> <span class="nav-text">元组结构体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.2.3.</span> <span class="nav-text">单元结构体</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%9E%9A%E4%B8%BE%E4%BD%93"><span class="nav-number">6.3.</span> <span class="nav-text">3. 枚举体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%9A%E4%B8%BE"><span class="nav-number">6.3.1.</span> <span class="nav-text">无参数枚举</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BBC%E6%9E%9A%E4%B8%BE%E4%BD%93"><span class="nav-number">6.3.2.</span> <span class="nav-text">类C枚举体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E6%9E%9A%E4%B8%BE%E4%BD%93"><span class="nav-number">6.3.3.</span> <span class="nav-text">带参数枚举体</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">常用集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%BA%8F%E5%88%97%EF%BC%9A-%E5%90%91%E9%87%8F"><span class="nav-number">7.1.</span> <span class="nav-text">线性序列： 向量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%BA%8F%E5%88%97%EF%BC%9A%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="nav-number">7.2.</span> <span class="nav-text">线性序列：双端队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%BA%8F%E5%88%97%EF%BC%9A-%E9%93%BE%E8%A1%A8"><span class="nav-number">7.3.</span> <span class="nav-text">线性序列： 链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Key-Value%E6%98%A0%E5%B0%84%E8%A1%A8%EF%BC%9AHashMap%E5%92%8CBTreeMap"><span class="nav-number">7.4.</span> <span class="nav-text">Key-Value映射表：HashMap和BTreeMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%EF%BC%9A-HashSet%E5%92%8CBTreeSet"><span class="nav-number">7.5.</span> <span class="nav-text">集合： HashSet和BTreeSet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%9A-BinaryHeap"><span class="nav-number">7.6.</span> <span class="nav-text">优先队列： BinaryHeap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8Ctrait"><span class="nav-number">9.</span> <span class="nav-text">泛型和trait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">10.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">11.</span> <span class="nav-text">表达式优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%89%93%E5%8D%B0"><span class="nav-number">12.</span> <span class="nav-text">注释与打印</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">12.1.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%8D%B0"><span class="nav-number">12.2.</span> <span class="nav-text">打印</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Henry Xue</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry Xue</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">35k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">32 mins.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
